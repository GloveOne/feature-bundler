
==================== ../netvacinas-frontend/src/components/UploadShots/EditableApplicationItem.tsx ====================

// src/components/UploadShots/EditableApplicationItem.tsx
import React, { useMemo } from "react";

import {
  Alert,
  Box,
  Chip,
  FormControl,
  Grid,
  IconButton,
  InputLabel,
  MenuItem,
  Paper,
  Select,
  Stack, // Import Stack if you want to group index and icons nicely
  TextField,
  Tooltip,
  Typography,
} from "@mui/material";
import { SelectChangeEvent } from "@mui/material/Select";

import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import CheckCircleOutlineIcon from "@mui/icons-material/CheckCircleOutline";
import DeleteIcon from "@mui/icons-material/Delete";
import InfoIcon from "@mui/icons-material/Info";
import WarningAmberIcon from "@mui/icons-material/WarningAmber";

import {
  EditableVaccineApplication,
  GeminiExtractedApplication,
  SystemDose,
  SystemVaccine,
} from "./types";

// --- Constants ---
const DEFAULT_VALUE_FOR_MISSING_FIELD = "(Não especificado)";
// --- End Constants ---

interface EditableApplicationItemProps {
  app: EditableVaccineApplication;
  displayIndex: number; // New prop for the 1-based index
  systemVaccines: SystemVaccine[];
  activeVaccinesLoading: boolean;
  isSavingGlobally: boolean;
  onFieldChange: (
    appId: string | number,
    field: keyof GeminiExtractedApplication,
    value: string
  ) => void;
  onVaccineSelectChange: (appId: string | number, event: SelectChangeEvent<string>) => void;
  onDoseSelectChange: (appId: string | number, event: SelectChangeEvent<string>) => void; // <<<< NEW PROP
  onToggleReviewed: (appId: string | number) => void;
  onRemove: (appId: string | number) => void;
  showDivider: boolean;
}

// Helper function for dynamic helper text
const getHelperText = (
  currentValue: string | undefined | null,
  originalValue: string | undefined | null
): string => {
  const currentDisplayValue =
    currentValue === DEFAULT_VALUE_FOR_MISSING_FIELD ? "" : currentValue || "";
  const originalDisplayValue =
    originalValue === DEFAULT_VALUE_FOR_MISSING_FIELD ? "" : originalValue; // Treat original DEFAULT as blank for comparison here

  if (typeof originalValue === "undefined") {
    // This field was not part of the original Gemini extraction for this item (e.g., manually added item)
    // or the original_* field was never set.
    return ""; // No specific helper text needed for "original"
  }

  if (originalValue === DEFAULT_VALUE_FOR_MISSING_FIELD) {
    // Gemini explicitly said "Não especificado"
    return "Não especificado";
  }

  // If user changed it AND original was not effectively blank
  if (
    currentDisplayValue.trim() !== (originalDisplayValue || "").trim() &&
    (originalDisplayValue || "").trim() !== ""
  ) {
    return `Lido: ${originalDisplayValue}`;
  }

  // If value matches original, or original was truly blank (not placeholder), no extra helper text
  return "";
};

export const EditableApplicationItem: React.FC<EditableApplicationItemProps> = React.memo(
  ({
    app,
    displayIndex,
    systemVaccines,
    activeVaccinesLoading,
    isSavingGlobally,
    onFieldChange,
    onVaccineSelectChange,
    onDoseSelectChange, // <<<< NEW PROP
    onToggleReviewed,
    onRemove,
  }) => {
    const handleFieldChange = (field: keyof GeminiExtractedApplication, value: string) => {
      onFieldChange(app.id, field, value);
    };

    const handleVaccineChange = (event: SelectChangeEvent<string>) => {
      onVaccineSelectChange(app.id, event);
    };

    const handleDoseChange = (event: SelectChangeEvent<string>) => {
      onDoseSelectChange(app.id, event);
    };

    const handleToggle = () => {
      onToggleReviewed(app.id);
    };

    const handleRemove = () => {
      onRemove(app.id);
    };

    // Find the currently selected vaccine's possible doses
    const possibleDoses: SystemDose[] = useMemo(() => {
      if (!app.selectedVaccineId) return [];
      return systemVaccines.find(v => v.id === app.selectedVaccineId)?.doses || [];
    }, [app.selectedVaccineId, systemVaccines]);

    return (
      <Box
        component={Paper}
        variant="outlined"
        sx={{
          mb: 0.7,
          p: 0.6,
          borderLeft: app.saveError
            ? "4px solid red"
            : app.saveSuccess
            ? "4px solid green"
            : undefined,
        }}
      >
        <Grid container spacing={0} alignItems="flex-start">
          {/* Left Column: Index Number and Delete Icon */}
          <Grid
            item
            xs={12}
            md={1}
            sx={{
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "flex-start",
              pt: { xs: 0, md: "0px" },
            }}
          >
            <Typography
              variant="h5"
              component="div"
              sx={{
                fontWeight: "bold",
                mt: 1, // Adjusted margin-top slightly
                mb: 2, // Adjusted margin-bottom slightly
                // Custom styling examples:
                color: "primary.main", // Example: Use primary theme color
                // backgroundColor: theme => theme.palette.grey[200], // Example: Light grey background
                // padding: theme => theme.spacing(0.25, 1), // Example: Small padding (top/bottom, left/right)
                // borderRadius: theme => theme.shape.borderRadius, // Example: Rounded corners like theme
                // border: theme => `1px solid ${theme.palette.primary.light}`, // Example: Light border
                minWidth: "20px", // Ensure it has some minimum width for alignment
                textAlign: "center", // Center the number if it's a single digit
                lineHeight: 1.2, // Adjust line height for better vertical centering if bg is used
                paddingTop: "5px",
                paddingBottom: "0px",
                paddingLeft: "0px",
                paddingRight: "0px",
              }}
            >
              # {displayIndex}
            </Typography>
            <Stack direction="column" spacing={0.5} alignItems="center">
              {" "}
              {/* Stack for icons */}
              <Tooltip title="Remover esta aplicação">
                <span>
                  <IconButton
                    onClick={handleRemove}
                    size="small"
                    color="error"
                    aria-label="remover aplicação"
                    sx={{
                      mt: 1,
                      pt: 10,
                      display: "flex",
                      alignItems: "center",
                      paddingTop: "35px",
                      paddingBottom: "0px",
                      paddingLeft: "0px",
                      paddingRight: "0px",
                    }}
                    disabled={isSavingGlobally}
                  >
                    <DeleteIcon fontSize="large" />
                  </IconButton>
                </span>
              </Tooltip>
            </Stack>
          </Grid>

          {/* Right Column: Main Fields and "Reviewed" Toggle */}
          <Grid item xs={12} md={11}>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6} md={4} lg={3}>
                <TextField
                  label="Nome da Vacina (extraído da imagem)"
                  value={app.vaccine_name || ""}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  InputProps={{
                    readOnly: true,
                    style: { fontStyle: "italic", color: "grey" },
                  }}
                  helperText="Nome como extraído da imagem"
                />
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={3}>
                <FormControl
                  fullWidth
                  size="small"
                  error={!app.selectedVaccineId && !!app.saveError && !app.saveSuccess}
                >
                  <InputLabel id={`vaccine-select-label-${app.id}`}>Vacina do Sistema *</InputLabel>
                  <Select
                    labelId={`vaccine-select-label-${app.id}`}
                    id={`vaccine-select-${app.id}`}
                    value={app.selectedVaccineId || ""}
                    label="Vacina do Sistema *"
                    onChange={handleVaccineChange}
                    disabled={
                      isSavingGlobally || activeVaccinesLoading || systemVaccines.length === 0
                    }
                  >
                    <MenuItem value="">
                      <em>Selecione uma vacina</em>
                    </MenuItem>
                    {systemVaccines.map(sv => (
                      <MenuItem key={sv.id} value={sv.id}>
                        {sv.name}
                      </MenuItem>
                    ))}
                  </Select>
                  {app.closest_known_active_vaccine &&
                    app.closest_known_active_vaccine !== DEFAULT_VALUE_FOR_MISSING_FIELD && (
                      <Tooltip
                        title={`Sugestão da IA: ${app.closest_known_active_vaccine}`}
                        placement="top-start"
                      >
                        <Typography
                          variant="caption"
                          sx={{
                            display: "flex",
                            alignItems: "center",
                            mt: 0.5,
                            color: "text.secondary",
                          }}
                        >
                          <InfoIcon fontSize="small" sx={{ mr: 0.5 }} />
                          IA sugere:{" "}
                          {app.closest_known_active_vaccine.length > 30
                            ? `${app.closest_known_active_vaccine.substring(0, 27)}...`
                            : app.closest_known_active_vaccine}
                        </Typography>
                      </Tooltip>
                    )}
                </FormControl>
              </Grid>

              <Grid item xs={12} sm={6} md={4} lg={2}>
                <TextField
                  label="Data de Aplicação *"
                  value={app.application_date || ""}
                  onChange={e => handleFieldChange("application_date", e.target.value)}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  error={!app.application_date && !!app.saveError && !app.saveSuccess}
                  placeholder="DD/MM/AAAA"
                  helperText={getHelperText(app.application_date, app.original_application_date)}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={2}>
                <TextField
                  label="Fabricante"
                  value={
                    app.manufacturer === DEFAULT_VALUE_FOR_MISSING_FIELD
                      ? ""
                      : app.manufacturer || ""
                  }
                  onChange={e => handleFieldChange("manufacturer", e.target.value)}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  helperText={getHelperText(app.manufacturer, app.original_manufacturer)}
                />
              </Grid>

              <Grid item xs={12} sm={6} md={4} lg={2}>
                <TextField
                  label="Lote"
                  value={
                    app.batch_number === DEFAULT_VALUE_FOR_MISSING_FIELD
                      ? ""
                      : app.batch_number || ""
                  }
                  onChange={e => handleFieldChange("batch_number", e.target.value)}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  helperText={getHelperText(app.batch_number, app.original_batch_number)}
                />
              </Grid>

              <Grid item xs={12} sm={6} md={4} lg={2}>
                <FormControl fullWidth size="small">
                  <InputLabel id={`dose-select-label-${app.id}`}>Dose</InputLabel>
                  <Select
                    labelId={`dose-select-label-${app.id}`}
                    id={`dose-select-${app.id}`}
                    value={app.selectedDoseId || ""}
                    label="Dose"
                    onChange={handleDoseChange}
                    disabled={
                      isSavingGlobally || !app.selectedVaccineId || possibleDoses.length === 0
                    }
                  >
                    <MenuItem value="">
                      <em>Nenhuma / Não Aplicável</em>
                    </MenuItem>
                    {possibleDoses.map(dose => (
                      <MenuItem key={dose.id} value={dose.id}>
                        {dose.label}
                      </MenuItem>
                    ))}
                  </Select>
                  {app.suggested_dose && app.suggested_dose !== "(Não especificado)" && (
                    <Tooltip title={`Sugestão de dose da IA: ${app.suggested_dose}`}>
                      <Typography
                        variant="caption"
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          mt: 0.5,
                          color: "text.secondary",
                        }}
                      >
                        <InfoIcon fontSize="small" sx={{ mr: 0.5 }} />
                        IA: {app.suggested_dose}
                      </Typography>
                    </Tooltip>
                  )}
                </FormControl>
              </Grid>

              <Grid item xs={12} sm={6} md={4} lg={2}>
                <TextField
                  label="Data de Validade"
                  value={
                    app.expiry_date === DEFAULT_VALUE_FOR_MISSING_FIELD ? "" : app.expiry_date || ""
                  }
                  onChange={e => handleFieldChange("expiry_date", e.target.value)}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  helperText={getHelperText(app.expiry_date, app.original_expiry_date)}
                  placeholder="DD/MM/AAAA"
                />
              </Grid>

              <Grid item xs={12} sm={6} md={4} lg={2}>
                <TextField
                  label="Clínica de Aplicação"
                  value={
                    app.application_location === DEFAULT_VALUE_FOR_MISSING_FIELD
                      ? ""
                      : app.application_location || ""
                  }
                  onChange={e => handleFieldChange("application_location", e.target.value)}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  helperText={getHelperText(
                    app.application_location,
                    app.original_application_location
                  )}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={2}>
                <TextField
                  label="Registro da Aplicação"
                  value={
                    app.application_registry === DEFAULT_VALUE_FOR_MISSING_FIELD
                      ? ""
                      : app.application_registry || ""
                  }
                  onChange={e => handleFieldChange("application_registry", e.target.value)}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  helperText={getHelperText(
                    app.application_registry,
                    app.original_application_registry
                  )}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={2}>
                <TextField
                  label="Nome do Aplicador"
                  value={
                    app.applicator_name === DEFAULT_VALUE_FOR_MISSING_FIELD
                      ? ""
                      : app.applicator_name || ""
                  }
                  onChange={e => handleFieldChange("applicator_name", e.target.value)}
                  fullWidth
                  variant="outlined"
                  size="small"
                  disabled={isSavingGlobally}
                  helperText={getHelperText(app.applicator_name, app.original_applicator_name)}
                />
              </Grid>

              <Grid
                item
                xs={12}
                sm={6}
                md={4}
                lg={2}
                sx={{
                  display: "flex",
                  alignItems: "center", // This will vertically align Chip, Spacer, and IconButton
                  paddingTop: "0px",
                  paddingBottom: "15px",
                  paddingLeft: "0px",
                  paddingRight: "0px",
                }}
              >
                {/* Item 1: The Chip (remains on the left) */}
                {app.is_existing_record && (
                  <Tooltip title="Atenção: Este registro de vacina parece já existir no sistema do paciente. Verifique cuidadosamente antes de salvar para evitar duplicatas.">
                    <Chip
                      icon={<WarningAmberIcon />}
                      label="Registro já existente!"
                      size="medium"
                      color="error"
                      variant="outlined"
                      sx={{
                        borderColor: "#D32F2F",
                        color: "#D32F2F",
                        backgroundColor: "#FFEBEE",
                      }}
                    />
                  </Tooltip>
                )}

                {/* Item 2: The Spacer - This is the key change */}
                <Box sx={{ flexGrow: 1 }} />
                {/* `flexGrow: 1` tells this Box to expand and take up all available horizontal space */}

                {/* Item 3: The Reviewed Toggle (will now be pushed to the right) */}
                <Tooltip title={app.isReviewed ? "Item Revisado!" : "Marcar como revisado"}>
                  <span>
                    <IconButton
                      onClick={handleToggle}
                      size="large"
                      color={app.isReviewed ? "success" : "default"}
                      aria-label={
                        app.isReviewed ? "marcar como não revisado" : "marcar como revisado"
                      }
                      disabled={isSavingGlobally}
                      sx={{
                        // Your padding can likely be simplified now that positioning is handled by flexbox
                        // For example, just add some left margin if needed:
                        // ml: 1
                        paddingLeft: "9px",
                        paddingRight: "10px", // Resetting padding from your example if it was just for spacing
                      }}
                    >
                      {app.isReviewed ? (
                        <CheckCircleIcon fontSize="large" />
                      ) : (
                        <CheckCircleOutlineIcon fontSize="large" />
                      )}
                    </IconButton>
                  </span>
                </Tooltip>
              </Grid>
            </Grid>{" "}
            {/* End of inner fields grid */}
            {/* Save Error/Success Messages */}
            {app.saveError && (
              <Alert severity="error" sx={{ mt: 1, fontSize: "0.8rem", p: "0px 8px" }}>
                {app.saveError}
              </Alert>
            )}
            {app.saveSuccess && (
              <Alert severity="success" sx={{ mt: 1, fontSize: "0.8rem", p: "0px 8px" }}>
                Salvo com sucesso!
              </Alert>
            )}
          </Grid>
        </Grid>
      </Box>
    );
  },
  (prevProps, nextProps) => {
    // Simplified memo comparison: re-render if app object reference changes,
    // or if other critical props that affect rendering logic change.
    // This relies on the parent creating new 'app' objects only when their data truly changes.
    if (
      prevProps.app !== nextProps.app ||
      prevProps.systemVaccines !== nextProps.systemVaccines || // Essential if vaccine list changes
      prevProps.activeVaccinesLoading !== nextProps.activeVaccinesLoading ||
      prevProps.isSavingGlobally !== nextProps.isSavingGlobally ||
      prevProps.showDivider !== nextProps.showDivider
    ) {
      return false; // Re-render
    }
    return true; // Props are considered the same, skip re-render
  }
);


==================== ../netvacinas-frontend/src/components/UploadShots/dialog.tsx ====================

// netvacinas-frontend/src/components/UploadShots/dialog.tsx
import React from "react";

import { Dialog, DialogContent, DialogTitle } from "@mui/material";

import { useCurrentPatient } from "../PatientCard"; // To get patientId

import { UploadShotsForm } from "./form"; // Assuming form.tsx is in the same directory

interface UploadShotsDialogProps {
  open: boolean;
  onClose: () => void;
}

export const UploadShotsDialog: React.FC<UploadShotsDialogProps> = ({ open, onClose }) => {
  const patient = useCurrentPatient(); // Get current patient context

  // --- Quick Console Log (and debugger) to Inspect Patient Object ---
  // React.useEffect(() => {
  //   // debugger;
  //   if (patient) {
  //     console.log("Current Patient Object in UploadShotsDialog:", patient);
  //     // You can log specific properties too:
  //     // console.log("Patient ID:", patient.id);
  //     // console.log("Patient Name:", patient.name); // Assuming it has a name property
  //   } else {
  //     console.log("UploadShotsDialog: Patient object is null or undefined.");
  //   }
  // }, [patient]); // Re-run this effect if the patient object changes

  // It's important to handle the case where patient or patient.id might not be available
  // For instance, if the dialog is somehow rendered when no patient is selected.
  // You might want to disable the button that opens the dialog in such cases.
  if (!patient || !patient.id) {
    // Or render a message inside the dialog, or simply don't render the form
    console.warn("UploadShotsDialog: Patient ID is not available.");
    return null;
  }

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="xl"
      fullWidth
      scroll="paper" // Important for allowing content to scroll within the paper
      sx={{ "& .MuiDialog-paper": { maxHeight: "95vh" } }}
    >
      <DialogTitle>Upload de Arquivos da Carteirinha</DialogTitle>
      <DialogContent sx={{ pt: "0px", flexGrow: 1, overflowY: "auto" }}>
        {/* MUI DialogContent sometimes adds too much top padding */}
        <UploadShotsForm patientId={patient.id} onClose={onClose} />
      </DialogContent>
    </Dialog>
  );
};


==================== ../netvacinas-frontend/src/components/UploadShots/form.tsx ====================

// /home/gnavarro/Development/netvacinas-frontend/src/components/UploadShots/form.tsx
import React, {
  ChangeEvent,
  FormEvent,
  KeyboardEvent,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from "react";
import { useDebounce } from "react-use";

import {
  Alert,
  Box,
  Button,
  CircularProgress,
  Grid,
  InputAdornment,
  List,
  Paper,
  Stack,
  TextField,
  Typography,
} from "@mui/material";
import { SelectChangeEvent } from "@mui/material/Select";

import AddCircleOutlineIcon from "@mui/icons-material/AddCircleOutline";
import SearchIcon from "@mui/icons-material/Search";

import { ApolloError, useMutation, useQuery } from "@apollo/client";

import {
  patientQuery,
  SAVE_EXTRACTED_VACCINE_APPLICATIONS_MUTATION,
  vaccineListQuery,
} from "../../data/queries";
import { useSuccessMessage } from "../../lib/notification";

import { EditableApplicationItem } from "./EditableApplicationItem";
import {
  EditableVaccineApplication,
  GeminiExtractedApplication,
  GeminiVaccinationCardData,
  SystemVaccine,
} from "./types";
import { useUploadShots } from "./useUploadShots";

const DEBOUNCE_DELAY = 400;
const DEFAULT_VALUE_FOR_MISSING_FIELD = "(Não especificado)";

interface UploadShotsFormProps {
  patientId: string;
  onClose?: () => void;
}

const formatDateToYYYYMMDD = (dateString: string): string => {
  if (!dateString || typeof dateString !== "string") return "";
  const parts = dateString.split("/");
  if (parts.length === 3) {
    const [day, month, year] = parts;
    if (
      day &&
      month &&
      year &&
      day.length === 2 &&
      month.length === 2 &&
      (year.length === 4 || year.length === 2)
    ) {
      const fullYear =
        year.length === 2 ? (parseInt(year, 10) > 50 ? `19${year}` : `20${year}`) : year;
      return `${fullYear}-${month}-${day}`;
    }
  }
  if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
    return dateString;
  }
  console.warn(`Date string "${dateString}" is not in expected DD/MM/YYYY format for conversion.`);
  return dateString;
};

export const UploadShotsForm: React.FC<UploadShotsFormProps> = ({ patientId, onClose }) => {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [editableApplications, setEditableApplications] = useState<EditableVaccineApplication[]>(
    []
  );
  const [showResults, setShowResults] = useState<boolean>(false);
  const [inputValue, setInputValue] = useState<string>("");
  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState<string>("");

  const [, cancelDebounce] = useDebounce(
    () => {
      setDebouncedSearchTerm(inputValue);
    },
    DEBOUNCE_DELAY,
    [inputValue]
  );
  useEffect(() => () => cancelDebounce(), [cancelDebounce]);

  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [saveOverallError, setSaveOverallError] = useState<string | null>(null);

  const {
    data: activeVaccinesData,
    loading: activeVaccinesLoading,
    error: activeVaccinesError,
  } = useQuery(vaccineListQuery, {
    variables: {
      patientId: patientId,
      inventoryDate: new Date().toISOString().split("T")[0],
      withPrice: false,
      withPrices: false,
      withInventoryCount: false,
      withDiscounts: false,
      withFees: false,
      withDoses: true, // Fetch doses for each vaccine
      withApplicationSites: false,
      withApplicationMethods: false,
      withManufacturers: false,
      withBatches: false,
      withSuggestions: false,
      withReservable: false,
      withoutInventoryBatches: true,
      withoutInventoryCountBatches: true,
    },
    skip: !patientId,
  });

  const systemVaccines: SystemVaccine[] = useMemo(() => {
    return (
      activeVaccinesData?.vaccines
        ?.filter((v: any) => v.id && v.name)
        .map((v: any) => ({ id: v.id, name: v.name, doses: v.doses || [] })) || []
    );
  }, [activeVaccinesData]);

  const { processFile, isProcessing: isExtracting, error: processError } = useUploadShots({
    patientId,
    onUploadSuccess: useCallback(
      (response: GeminiVaccinationCardData | null) => {
        const currentSystemVaccines = systemVaccines;
        if (response && response.vaccine_applications) {
          const newApps = response.vaccine_applications.map(
            (geminiApp: GeminiExtractedApplication, index: number) => {
              let preSelectedVaccineId: string | null = null;
              let preSelectedDoseId: string | null = null;
              // <<<< THIS IS THE CORRECTED LOGIC WITH THE IF BLOCK RESTORED >>>>
              if (
                geminiApp.closest_known_active_vaccine &&
                geminiApp.closest_known_active_vaccine !== DEFAULT_VALUE_FOR_MISSING_FIELD &&
                currentSystemVaccines.length > 0
              ) {
                const foundVaccine = currentSystemVaccines.find(
                  sv => sv.name === geminiApp.closest_known_active_vaccine
                );

                if (foundVaccine) {
                  // Step 1: Pre-select the vaccine
                  preSelectedVaccineId = foundVaccine.id;
                  // Step 2: Use the found vaccine's dose list to pre-select the dose
                  if (
                    geminiApp.suggested_dose &&
                    geminiApp.suggested_dose !== DEFAULT_VALUE_FOR_MISSING_FIELD
                  ) {
                    const foundDose = foundVaccine.doses.find(
                      d => d.label === geminiApp.suggested_dose
                    );
                    if (foundDose) {
                      preSelectedDoseId = foundDose.id;
                    }
                  }
                }
              }

              return {
                ...geminiApp,
                id: `initial-${index}-${Date.now()}`,
                isReviewed: false,
                selectedVaccineId: preSelectedVaccineId,
                selectedDoseId: preSelectedDoseId,
                saveError: null,
                saveSuccess: false,
                original_application_date: geminiApp.application_date,
                original_manufacturer: geminiApp.manufacturer,
                original_batch_number: geminiApp.batch_number,
                original_expiry_date: geminiApp.expiry_date,
                original_application_location: geminiApp.application_location,
                original_application_registry: geminiApp.application_registry,
                original_applicator_name: geminiApp.applicator_name,
              };
            }
          );
          setEditableApplications(newApps);
          setShowResults(true);
        } else {
          setEditableApplications([]);
          setShowResults(true);
        }
        setInputValue("");
        setDebouncedSearchTerm("");
        setSaveOverallError(null);
      },
      [systemVaccines]
    ),
    onUploadError: useCallback(
      (_errorMessages: string[] | null, _rawError?: Error | ApolloError) => {
        setShowResults(false);
        setEditableApplications([]);
        setInputValue("");
        setDebouncedSearchTerm("");
        setSaveOverallError(null);
      },
      []
    ),
  });

  // This composite useEffect handles pre-selection and invalidation for doses
  useEffect(() => {
    // Only run if we have data to work with
    if (systemVaccines.length === 0 || editableApplications.length === 0) return;

    // Use a variable to track if any changes were made to avoid unnecessary re-renders
    let didChange = false;
    const newApps = editableApplications.map(app => {
      const newApp = { ...app };

      // Case 1: Pre-select dose if a vaccine was just selected by user/another effect
      if (
        newApp.selectedVaccineId &&
        !newApp.selectedDoseId &&
        newApp.suggested_dose &&
        newApp.suggested_dose !== DEFAULT_VALUE_FOR_MISSING_FIELD
      ) {
        const selectedVaccine = systemVaccines.find(v => v.id === newApp.selectedVaccineId);
        const foundDose = selectedVaccine?.doses.find(d => d.label === newApp.suggested_dose);
        if (foundDose) {
          newApp.selectedDoseId = foundDose.id;
          didChange = true;
        }
      }

      // Case 2: Invalidate selected dose if vaccine changes and dose is no longer valid
      if (newApp.selectedVaccineId && newApp.selectedDoseId) {
        const selectedVaccine = systemVaccines.find(v => v.id === newApp.selectedVaccineId);
        const doseStillValid = selectedVaccine?.doses.some(d => d.id === newApp.selectedDoseId);
        if (!doseStillValid) {
          newApp.selectedDoseId = null;
          didChange = true;
        }
      }
      return newApp;
    });

    if (didChange) {
      setEditableApplications(newApps);
    }
  }, [editableApplications, systemVaccines]);

  useEffect(() => {
    if (!selectedFile) {
      setEditableApplications([]);
      setShowResults(false);
      setInputValue("");
      setDebouncedSearchTerm("");
      setSaveOverallError(null);
    }
  }, [selectedFile]);

  const handleFileChange = useCallback((event: ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      setSelectedFile(event.target.files[0]);
      // Reset other states
      setShowResults(false);
      setEditableApplications([]);
      setInputValue("");
      setDebouncedSearchTerm("");
      setSaveOverallError(null);
    } else {
      if (!event.target.files || event.target.files.length === 0) {
        setSelectedFile(null);
      }
    }
  }, []);

  const handleSubmitFileExtraction = useCallback(
    async (event: FormEvent) => {
      event.preventDefault();
      if (selectedFile) {
        setShowResults(false);
        setEditableApplications([]);
        setInputValue("");
        setDebouncedSearchTerm("");
        setSaveOverallError(null);
        await processFile(selectedFile);
      }
    },
    [selectedFile, processFile]
  );

  const handleApplicationFieldChange = useCallback(
    (appId: string | number, field: keyof GeminiExtractedApplication, value: string) => {
      setEditableApplications(prevApps =>
        prevApps.map(app =>
          app.id === appId ? { ...app, [field]: value, saveError: null, saveSuccess: false } : app
        )
      );
    },
    []
  );

  const handleSelectedVaccineChange = useCallback(
    (appId: string | number, event: SelectChangeEvent<string>) => {
      const newVaccineId = event.target.value || null;
      setEditableApplications(prevApps =>
        prevApps.map(app =>
          app.id === appId
            ? // Clear the dose when vaccine changes, let useEffect handle pre-selection
              {
                ...app,
                selectedVaccineId: newVaccineId,
                selectedDoseId: null,
                saveError: null,
                saveSuccess: false,
              }
            : app
        )
      );
    },
    []
  );

  const handleDoseChange = useCallback(
    (appId: string | number, event: SelectChangeEvent<string>) => {
      const newDoseId = event.target.value || null;
      setEditableApplications(prevApps =>
        prevApps.map(app =>
          app.id === appId
            ? { ...app, selectedDoseId: newDoseId, saveError: null, saveSuccess: false }
            : app
        )
      );
    },
    []
  );

  const handleToggleReviewed = useCallback((idToToggle: string | number) => {
    setEditableApplications(prevApps =>
      prevApps.map(app => (app.id === idToToggle ? { ...app, isReviewed: !app.isReviewed } : app))
    );
  }, []);

  const handleRemoveApplication = useCallback((idToRemove: string | number) => {
    setEditableApplications(prev => prev.filter(app => app.id !== idToRemove));
  }, []);

  const handleAddApplication = useCallback(() => {
    setEditableApplications(prev => [
      ...prev,
      {
        id: `manual-${Date.now()}`,
        vaccine_name: "",
        application_date: "",
        original_application_date: undefined,
        manufacturer: "",
        original_manufacturer: undefined,
        batch_number: "",
        original_batch_number: undefined,
        expiry_date: "",
        original_expiry_date: undefined,
        application_location: "",
        original_application_location: undefined,
        application_registry: "",
        original_application_registry: undefined,
        applicator_name: "",
        original_applicator_name: undefined,
        is_existing_record: false,
        closest_known_active_vaccine: DEFAULT_VALUE_FOR_MISSING_FIELD,
        suggested_dose: DEFAULT_VALUE_FOR_MISSING_FIELD,
        isReviewed: false,
        selectedVaccineId: null,
        selectedDoseId: null,
        saveError: null,
        saveSuccess: false,
      },
    ]);
    setInputValue("");
    setDebouncedSearchTerm("");
  }, []);

  const [callSaveApplications] = useMutation(SAVE_EXTRACTED_VACCINE_APPLICATIONS_MUTATION, {
    // Add the refetchQueries option to the useMutation hook itself
    refetchQueries: [
      {
        query: patientQuery,
        variables: {
          id: patientId,
          withShots: true,
          withNonImmunizedDiseases: true,
          withFullProfile: true,
        },
      },
      // You can add more queries to refetch here if needed
      // { query: anotherQuery, variables: { ... } }
    ],
    // This makes the refetch happen automatically on successful mutation,
    // without needing to specify it in the handleConfirmAndSave call.
  });
  const showSuccessMessage = useSuccessMessage();

  const handleConfirmAndSave = useCallback(async () => {
    setIsSaving(true);
    setSaveOverallError(null);
    setEditableApplications(apps =>
      apps.map(app => ({ ...app, saveError: null, saveSuccess: false }))
    );

    const applicationsToSave = editableApplications.map(app => {
      const observationsParts: string[] = [];
      if (app.vaccine_name && app.vaccine_name !== DEFAULT_VALUE_FOR_MISSING_FIELD) {
        const selectedVaccine = systemVaccines.find(sv => sv.id === app.selectedVaccineId);
        if (
          (selectedVaccine &&
            selectedVaccine.name.toLowerCase() !== app.vaccine_name.toLowerCase()) ||
          !selectedVaccine
        ) {
          observationsParts.push(`Nome original da carteirinha: ${app.vaccine_name}`);
        }
      }
      if (app.expiry_date && app.expiry_date !== DEFAULT_VALUE_FOR_MISSING_FIELD)
        observationsParts.push(`Validade do lote: ${app.expiry_date}`);
      if (app.application_location && app.application_location !== DEFAULT_VALUE_FOR_MISSING_FIELD)
        observationsParts.push(`Local: ${app.application_location}`);
      if (app.application_registry && app.application_registry !== DEFAULT_VALUE_FOR_MISSING_FIELD)
        observationsParts.push(`Registro: ${app.application_registry}`);
      if (app.applicator_name && app.applicator_name !== DEFAULT_VALUE_FOR_MISSING_FIELD)
        observationsParts.push(`Aplicador: ${app.applicator_name}`);
      if (app.is_existing_record)
        observationsParts.push("Identificado como registro já existente no sistema.");

      return {
        vaccineId: app.selectedVaccineId,
        applicationDate: formatDateToYYYYMMDD(app.application_date),
        doseId: app.selectedDoseId, // Pass the selected dose ID
        manufacturerName:
          app.manufacturer === DEFAULT_VALUE_FOR_MISSING_FIELD ? "" : app.manufacturer,
        batchNumber: app.batch_number === DEFAULT_VALUE_FOR_MISSING_FIELD ? "" : app.batch_number,
        observations: observationsParts.join(" | "),
      };
    });

    const invalidAppIndex = applicationsToSave.findIndex(
      app => !app.vaccineId || !app.applicationDate
    );
    if (invalidAppIndex !== -1) {
      const appWithError = editableApplications[invalidAppIndex];
      if (appWithError) {
        const errorMsg = `Aplicação #${invalidAppIndex + 1} (${
          appWithError.vaccine_name || "Nome não preenchido"
        }): Por favor, selecione uma vacina do sistema e informe a data de aplicação.`;
        setSaveOverallError(errorMsg);
        setEditableApplications(prevApps =>
          prevApps.map((app, idx) =>
            idx === invalidAppIndex
              ? { ...app, saveError: "Vacina do sistema e data de aplicação são obrigatórias." }
              : app
          )
        );
      } else {
        const genericErrorMsg = `Erro de validação na Aplicação #${
          invalidAppIndex + 1
        }: Dados inválidos.`;
        setSaveOverallError(genericErrorMsg);
        setEditableApplications(prevApps =>
          prevApps.map((app, idx) =>
            idx === invalidAppIndex
              ? { ...app, saveError: "Erro interno ao validar esta aplicação." }
              : app
          )
        );
        console.error("CRITICAL: appWithError was undefined for a valid-seeming index.", {
          invalidAppIndex,
          editableApplications,
        });
      }
      setIsSaving(false);
      return;
    }

    try {
      const { data } = await callSaveApplications({
        variables: { input: { patientId, applications: applicationsToSave } },
      });
      const payload = data?.saveExtractedVaccineApplications?.payload;
      if (payload) {
        const allSuccessful = payload.overallSuccess;
        setEditableApplications(prevApps =>
          prevApps.map((app, index) => {
            const result = payload.processedApplications.find((pa: any) => pa.inputIndex === index);
            return result
              ? {
                  ...app,
                  saveSuccess: result.success,
                  saveError: result.success
                    ? null
                    : result.errors?.join(", ") || "Falha ao salvar.",
                }
              : app;
          })
        );
        if (!allSuccessful) {
          const firstError =
            payload.processedApplications.find((pa: any) => !pa.success)?.errors?.join(", ") ||
            "Algumas aplicações falharam ao salvar.";
          setSaveOverallError(
            `Falha ao salvar uma ou mais aplicações. Verifique os erros individuais. Primeira falha: ${firstError}`
          );
        } else {
          const successfulSaves = payload.processedApplications.filter((pa: any) => pa.success)
            .length;
          showSuccessMessage(`${successfulSaves} Aplicações salvas com sucesso!`, {
            autoHideDuration: 5000,
            anchorOrigin: {
              vertical: "bottom",
              horizontal: "left",
            },
            // persist: false, // Default is false, so it auto-hides
            // action: null, // Explicitly no action, though default is usually none
          });
          if (onClose) onClose();
        }
      } else {
        setSaveOverallError("Resposta inesperada do servidor ao salvar.");
      }
    } catch (err) {
      console.error("Erro ao salvar aplicações:", err);
      let message = "Erro desconhecido ao salvar.";
      if (err instanceof ApolloError) {
        message =
          err.graphQLErrors.length > 0
            ? err.graphQLErrors.map(e => e.message).join("; ")
            : err.networkError
            ? `Erro de rede: ${err.networkError.message}`
            : err.message;
      } else if (err instanceof Error) {
        message = err.message;
      }
      setSaveOverallError(message);
    } finally {
      setIsSaving(false);
    }
  }, [
    editableApplications,
    patientId,
    callSaveApplications,
    onClose,
    systemVaccines,
    showSuccessMessage,
  ]);

  const filteredApplications = useMemo(() => {
    if (!debouncedSearchTerm.trim()) return editableApplications;
    const lowerCaseSearchTerm = debouncedSearchTerm.toLowerCase();
    return editableApplications.filter(app => {
      const {
        id,
        isReviewed,
        saveError,
        saveSuccess,
        selectedVaccineId,
        ...searchableAppFields
      } = app;
      const selectedVaccineName =
        systemVaccines.find(sv => sv.id === selectedVaccineId)?.name || "";
      return (
        Object.values(searchableAppFields).some(value =>
          String(value).toLowerCase().includes(lowerCaseSearchTerm)
        ) || selectedVaccineName.toLowerCase().includes(lowerCaseSearchTerm)
      );
    });
  }, [editableApplications, debouncedSearchTerm, systemVaccines]);

  // Moved handleSearchInputChange inside the component
  const handleSearchInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(event.target.value);
  };

  const handleSearchKeyDown = useCallback((event: KeyboardEvent<HTMLInputElement>) => {
    if (event.key === "Enter") event.preventDefault();
  }, []);

  const extractedButNoAppsToShow =
    showResults &&
    !isExtracting &&
    !processError &&
    editableApplications.length === 0 &&
    !debouncedSearchTerm.trim();

  return (
    <form
      onSubmit={handleSubmitFileExtraction}
      style={{ display: "flex", flexDirection: "column", height: "100%" }}
    >
      {/* Top Section: Instructions & File Input with Action Buttons */}
      <Box sx={{ mb: 1, flexShrink: 0 }}>
        {!showResults && (
          <Typography variant="body1" gutterBottom sx={{ mb: 1 }}>
            Selecione uma imagem da carteira de vacinação para extrair os dados.
          </Typography>
        )}
        <Grid container spacing={1} alignItems="center">
          <Grid item xs={12} sm>
            <TextField
              type="file"
              onChange={handleFileChange}
              fullWidth
              variant="outlined"
              size="small"
              inputProps={{ accept: "image/png, image/jpeg, image/webp, image/heic, image/heif" }}
              helperText={
                selectedFile
                  ? `Arquivo: ${selectedFile.name}`
                  : "Formatos suportados: PNG, JPG, WEBP, HEIC, HEIF."
              }
              error={!!processError && !isExtracting}
              disabled={isExtracting || isSaving}
            />
          </Grid>
          <Grid
            item
            xs={12}
            sm="auto"
            sx={{
              paddingTop: "30px",
              paddingBottom: "16.5px",
              paddingLeft: "10px",
              paddingRight: "10px",
            }}
          >
            <Stack
              direction="row"
              spacing={1}
              justifyContent={{ xs: "flex-end", sm: "flex-end" }}
              sx={{ width: "100%" }}
              alignItems="center"
            >
              <Button
                type="submit"
                variant="contained"
                disabled={isExtracting || isSaving || !selectedFile}
                size="medium"
              >
                {isExtracting ? "Processando..." : "Extrair Dados"}
              </Button>
            </Stack>
          </Grid>
        </Grid>
        {isExtracting && (
          <Box sx={{ display: "flex", alignItems: "center", my: 1 }}>
            <CircularProgress size={24} sx={{ mr: 1 }} />{" "}
            <Typography>Processando imagem com IA...</Typography>
          </Box>
        )}
        {processError && !isExtracting && (
          <Alert severity="error" sx={{ my: 1 }}>
            Erro ao extrair dados:{" "}
            {Array.isArray(processError) ? processError.join(", ") : String(processError)}
          </Alert>
        )}
      </Box>

      {saveOverallError && !isSaving && (
        <Alert severity="error" sx={{ my: 1, flexShrink: 0 }}>
          {saveOverallError}
        </Alert>
      )}

      {showResults && !isExtracting && !processError && (
        <Paper
          elevation={0}
          sx={{
            p: { xs: 0.5, sm: 1 },
            mt: 1,
            flexGrow: 1,
            overflow: "hidden",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <Typography variant="h6" gutterBottom sx={{ mb: 1, px: 1, flexShrink: 0 }}>
            Verifique e Edite os Dados Extraídos ({filteredApplications.length} de{" "}
            {editableApplications.length}):
          </Typography>
          <TextField
            label="Buscar nas aplicações extraídas"
            variant="outlined"
            size="small"
            fullWidth
            value={inputValue} // Correct: Bind to inputValue for immediate feedback
            onChange={handleSearchInputChange} // Correct: Use the new handler
            sx={{ mb: 1, px: 1, flexShrink: 0 }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
            onKeyDown={handleSearchKeyDown} // Keep if you want to prevent form submission on Enter
            disabled={isExtracting || isSaving || activeVaccinesLoading}
          />
          {activeVaccinesLoading && (
            <Typography sx={{ my: 1, textAlign: "center", flexShrink: 0 }}>
              <CircularProgress size={20} sx={{ mr: 1 }} />
              Carregando vacinas...
            </Typography>
          )}
          {activeVaccinesError && (
            <Alert severity="warning" sx={{ my: 1, mx: 1, flexShrink: 0 }}>
              Erro ao carregar vacinas: {activeVaccinesError.message}
            </Alert>
          )}

          <Box sx={{ flexGrow: 1, overflowY: "auto", pr: { xs: 0, sm: 0.5 }, mt: 1 }}>
            {!activeVaccinesLoading && filteredApplications.length > 0 ? (
              <List dense disablePadding sx={{ pt: 0.5 }}>
                {filteredApplications.map((app, idx) => (
                  <EditableApplicationItem
                    key={app.id}
                    app={app}
                    displayIndex={idx + 1}
                    systemVaccines={systemVaccines}
                    activeVaccinesLoading={activeVaccinesLoading}
                    isSavingGlobally={isSaving}
                    onFieldChange={handleApplicationFieldChange}
                    onVaccineSelectChange={handleSelectedVaccineChange}
                    onToggleReviewed={handleToggleReviewed}
                    onRemove={handleRemoveApplication}
                    onDoseSelectChange={handleDoseChange} // Pass the new handler
                    showDivider={idx < filteredApplications.length - 1}
                  />
                ))}
              </List>
            ) : (
              !activeVaccinesLoading && (
                <Typography sx={{ my: 2, textAlign: "center" }}>
                  {isExtracting
                    ? "Aguarde..."
                    : debouncedSearchTerm.trim()
                    ? `Nenhuma aplicação encontrada para "${debouncedSearchTerm}".`
                    : "Nenhuma aplicação para editar. Extraia dados ou adicione manualmente."}
                </Typography>
              )
            )}
          </Box>
          <Button
            startIcon={<AddCircleOutlineIcon />}
            onClick={handleAddApplication}
            variant="outlined"
            size="small"
            sx={{ mt: 1, display: "block", mx: "auto", flexShrink: 0 }}
            disabled={isExtracting || isSaving || activeVaccinesLoading}
          >
            Adicionar Aplicação Manualmente
          </Button>
        </Paper>
      )}

      {extractedButNoAppsToShow && (
        <Typography sx={{ mt: 2, textAlign: "center", flexShrink: 0 }}>
          Nenhuma aplicação de vacina foi extraída da imagem. Você pode adicionar manualmente.
        </Typography>
      )}

      <Stack
        direction="row"
        justifyContent="space-between"
        alignItems="center"
        spacing={1}
        sx={{
          mt: "auto",
          pt: 2,
          borderTop: theme => `1px solid ${theme.palette.divider}`,
          flexShrink: 0,
        }}
      >
        <Button
          onClick={onClose}
          disabled={isExtracting || isSaving}
          variant="outlined"
          color="inherit"
        >
          Cancelar
        </Button>
        {editableApplications.length > 0 && !isExtracting && (
          <Button
            onClick={handleConfirmAndSave}
            variant="contained"
            color="primary"
            disabled={
              isSaving || isExtracting || editableApplications.length === 0 || activeVaccinesLoading
            }
          >
            {isSaving ? "Salvando..." : "Confirmar e Salvar Dados"}
          </Button>
        )}
      </Stack>
    </form>
  );
};


==================== ../netvacinas/app/services/gemini_api_service.rb ====================

# File Path: app/services/gemini_api_service.rb

require 'net/http'
require 'uri'
require 'json'
require 'base64'
# fuzzy_match is no longer directly used by this service if Gemini handles closest match.
# You can remove it from here and Gemfile if not used elsewhere.
# require 'fuzzy_match'

class GeminiApiService
  ServiceResponse = Struct.new(:success?, :data, :errors) do
    def self.success(data)
      new(true, data, nil)
    end

    def self.failure(errors)
      new(false, nil, Array(errors).map(&:to_s))
    end
  end

  GEMINI_MODEL_IDENTIFIER = "gemini-2.5-flash" # Your confirmed model
  GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models"
  MAX_REQUEST_SIZE_BYTES = 20 * 1024 * 1024

  # Keys Gemini extracts from the IMAGE
  IMAGE_EXTRACTED_KEYS = [
    "vaccine_name", "application_date", "manufacturer", "batch_number",
    "expiry_date", "application_location", "application_registry",
    "applicator_name"
  ].freeze

  # Keys Gemini DERIVES based on CONTEXT
  CONTEXT_DERIVED_KEYS = [
    "is_existing_record", "closest_known_active_vaccine", "suggested_dose"
  ].freeze

  DEFAULT_VALUE_FOR_MISSING_FIELD = "(Não especificado)".freeze
  UNCERTAIN_FIELD_MARKER = " (?)".freeze

  VACCINATION_CARD_DATA_SCHEMA = {
    type: "OBJECT",
    properties: {
      vaccine_applications: {
        type: "ARRAY",
        description: "Uma lista de todas as aplicações de vacinas identificadas na carteirinha, incluindo informações de correlação.",
        items: {
          type: "OBJECT",
          description: "Detalhes de uma única aplicação de vacina, incluindo informações derivadas do contexto fornecido.",
          properties: {
            vaccine_name: { type: "STRING", description: "Nome da Vacina. Capture da imagem o nome mais completo e descritivo. Mantenha a capitalização original." },
            application_date: { type: "STRING", description: "Data de Aplicação (DD/MM/AAAA) conforme a imagem. Se ilegível/incerta, anexe '#{UNCERTAIN_FIELD_MARKER}' à data." },
            manufacturer: { type: "STRING", description: "Fabricante conforme a imagem. Infira se possível. Se ausente na imagem, use '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'." },
            batch_number: { type: "STRING", description: "Lote conforme a imagem. Se ausente na imagem, use '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'." },
            expiry_date: { type: "STRING", description: "Data de Validade do lote (DD/MM/AAAA) conforme a imagem. Se ausente na imagem, use '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'." },
            application_location: { type: "STRING", description: "Local de Aplicação conforme a imagem. Se ausente na imagem, use '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'." },
            application_registry: { type: "STRING", description: "Registro da Aplicação conforme a imagem. Se ausente na imagem, use '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'." },
            applicator_name: { type: "STRING", description: "Nome do profissional que aplicou a vacina, conforme a imagem. Se ausente na imagem, use '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'." },
            is_existing_record: {
              type: "BOOLEAN",
              description: "Avalie se esta aplicação de vacina (baseada no `vaccine_name` e `application_date` extraídos da imagem) corresponde a um dos 'Registros de vacinas existentes para este paciente' fornecidos no contexto do prompt. Defina como `true` se houver uma correspondência razoável (considere pequenas variações no nome da vacina e garanta que as datas sejam as mesmas). Caso contrário, ou se não houver registros de contexto, defina como `false`."
            },
            closest_known_active_vaccine: {
              type: "STRING",
              description: "Do `vaccine_name` extraído da imagem, encontre o nome MAIS SIMILAR da lista 'Vacinas ativas conhecidas' (fornecida no contexto do prompt). Retorne o nome EXATO da lista de 'Vacinas ativas conhecidas'. Se não houver uma correspondência próxima, se a lista de vacinas ativas não for fornecida, ou se o `vaccine_name` extraído for '#{DEFAULT_VALUE_FOR_MISSING_FIELD}', retorne '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'."
            },
            suggested_dose: {
              type: "STRING",
              description: "Baseado no `closest_known_active_vaccine` e no conteúdo da imagem, sugira a dose mais provável da lista de 'Doses Possíveis por Vacina' fornecida no contexto. Por exemplo, se a imagem diz 'D1' ou '1a', e as doses possíveis para a vacina sugerida são ['1ª Dose', '2ª Dose'], retorne '1ª Dose'. Retorne a string exata da dose da lista. Se nenhuma dose for provável, retorne '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'."
            }
          },
          required: ["vaccine_name", "application_date"] # Core fields from image
        }
      }
    },
    required: ["vaccine_applications"]
  }.freeze

  VACCINATION_CARD_PROMPT = <<~PROMPT.strip
    **Objetivo:** Analisar a imagem de uma carteira de vacinação e extrair informações detalhadas sobre CADA APLICAÇÃO INDIVIDUAL de vacina registrada. Além disso, você deve correlacionar os dados extraídos com informações de contexto que serão fornecidas.

    **Instruções Detalhadas para Extração e Derivação:**

    1.  **Identifique Entradas Individuais da Imagem:** Para cada aplicação de vacina visível na imagem, colete os dados associados. Preste atenção para não duplicar entradas se a mesma vacina aparecer múltiplas vezes com as mesmas informações.

    2.  **Dados a Extrair da IMAGEM para CADA Aplicação (conforme o schema JSON):**
        - **`vaccine_name` (Nome da Vacina):** Nome completo e descritivo da vacina aplicada, conforme visível na imagem. **IMPORTANTE: Se o nome da vacina e o nome do fabricante aparecerem juntos na imagem (ex: "Hexavalente GSK" ou "Prevenar 13 Pfizer"), coloque APENAS o nome da vacina neste campo (ex: "Hexavalente" ou "Prevenar 13"). O nome do fabricante deve ir para o campo `manufacturer`.** Mantenha a capitalização original do nome da vacina.
        - **`application_date` (Data de Aplicação):** Data em que a vacina foi aplicada, conforme visível na imagem. Formato DD/MM/AAAA.
        - **`manufacturer` (Fabricante):** Nome do laboratório/fabricante da vacina, conforme visível na imagem. **Se você extraiu o fabricante junto com o nome da vacina no passo anterior, coloque o nome do fabricante aqui.** Se não estiver visível, infira se possível com base no nome da vacina (ex: "Prevenar 13" é geralmente "Pfizer" ou "Wyeth"). Mantenha a capitalização original.
        - **`batch_number` (Lote):** Número do lote da vacina, conforme visível na imagem.
        - **`expiry_date` (Data de Validade):** Data de validade do lote da vacina (DD/MM/AAAA), conforme visível na imagem.
        - **`application_location` (Local de Aplicação):** Nome da clínica ou local onde a vacina foi administrada, conforme visível na imagem.
        - **`application_registry` (Registro da Aplicação):** Número de registro ou identificador da aplicação, se houver, conforme visível na imagem.
        - **`applicator_name` (Nome do Aplicador):** Nome do profissional de saúde que administrou a vacina, conforme visível na imagem.

    3.  **Dados DERIVADOS (a serem preenchidos por você, Gemini, usando o CONTEXTO FORNECIDO abaixo):**
        Para cada aplicação de vacina que você extraiu da imagem no passo 2:
        - **`is_existing_record` (BOOLEAN):** Compare o `vaccine_name` e `application_date` (ambos extraídos da imagem no passo 2) com cada entrada na lista de "Registros de vacinas existentes para este paciente" (fornecida no contexto abaixo). Para que seja considerado uma correspondência (`true`):
            - O `vaccine_name` extraído da imagem deve ser muito similar ou idêntico a um `vaccine_name` nos registros existentes. Considere variações comuns, como abreviações (ex: "DTPA" vs "DTPa Acelular"), inclusão/omissão do fabricante no nome (ex: "Shingrix GSK" vs "Shingrix"), ou pequenas diferenças de escrita. O significado principal da vacina deve ser o mesmo.
            - A `application_date` extraída da imagem deve ser EXATAMENTE idêntica à `application_date` no registro existente (após ambas serem normalizadas para o formato DD/MM/AAAA).
            Se uma correspondência clara de nome E data for encontrada, defina este campo como `true`. Caso contrário, ou se a lista de "Registros de vacinas existentes" não for fornecida, defina como `false`.
        - **`closest_known_active_vaccine` (STRING):** Pegue o `vaccine_name` que você extraiu da imagem. Compare-o com cada nome na lista de "Vacinas ativas conhecidas" (fornecida no contexto abaixo). Retorne o nome EXATO da lista de "Vacinas ativas conhecidas" que for textualmente mais similar. O objetivo é encontrar a melhor correspondência possível.
            - Exemplo: Se o nome extraído da imagem for "Pneumo 13v" e a lista de ativas contiver "Pneumo 15 - VAXNEUVANCE®" e "Pneumo 10", e "Pneumo 10" for o mais similar, retorne "Pneumo 10".
            - Exemplo: Se o nome extraído for "Vacina Gripe Comum" e a lista tiver "FLUARIX tetra gripe", retorne "FLUARIX tetra gripe" se for a correspondência mais próxima e razoável.
            Se nenhuma vacina na lista de "Vacinas ativas conhecidas" for suficientemente similar (ou seja, se o nome extraído for muito diferente de todos os nomes na lista), ou se a lista não for fornecida, ou se o `vaccine_name` extraído da imagem for nulo ou '#{DEFAULT_VALUE_FOR_MISSING_FIELD}', então retorne o valor literal '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'.
        - **`suggested_dose` (STRING):** Olhe para a vacina que você identificou em `closest_known_active_vaccine`. Agora, encontre a lista de doses para essa vacina no contexto "Doses Possíveis por Vacina". Compare essa lista com qualquer informação de dose na imagem (ex: "D1", "R", "2ª dose", anotações de reforço). Escolha e retorne a string EXATA da dose da lista que for a mais provável. Se nenhuma for provável ou a vacina não estiver na lista de doses, retorne '#{DEFAULT_VALUE_FOR_MISSING_FIELD}'.
    4.  **Política para Dados Ausentes/Ilegíveis nos campos extraídos da IMAGEM (APLIQUE A TODOS OS CAMPOS DO PASSO 2):**
        - **Ausente na Imagem:** Se uma informação para os campos `manufacturer`, `batch_number`, `expiry_date`, `application_location`, `application_registry`, ou `applicator_name` estiver completamente ausente na imagem, inclua o campo no JSON com o valor `#{DEFAULT_VALUE_FOR_MISSING_FIELD}`. Os campos `vaccine_name` e `application_date` devem sempre ser extraídos da imagem.
        - **Datas Ilegíveis/Incertas da Imagem (`application_date`, `expiry_date`):** Se qualquer parte da data estiver ilegível ou incerta na imagem, use o formato DD/MM/AAAA para a parte legível e anexe o marcador `#{UNCERTAIN_FIELD_MARKER}` ao final da string da data (ex: `DD/MM/????#{UNCERTAIN_FIELD_MARKER}` ou `??/MM/YYYY#{UNCERTAIN_FIELD_MARKER}`). Se completamente ilegível mas uma data é esperada, use `#{DEFAULT_VALUE_FOR_MISSING_FIELD}#{UNCERTAIN_FIELD_MARKER}`. Se legível, NÃO adicione o marcador.
        - **Outros Campos Ilegíveis da Imagem (`manufacturer`, `batch_number`, etc.):** Se parcialmente ilegível na imagem, transcreva a parte legível e anexe `#{UNCERTAIN_FIELD_MARKER}`. Se totalmente ilegível (mas o campo está presente na carteirinha), use `#{DEFAULT_VALUE_FOR_MISSING_FIELD}#{UNCERTAIN_FIELD_MARKER}`. Se o campo estiver completamente ausente na imagem, use `#{DEFAULT_VALUE_FOR_MISSING_FIELD}`.

    5.  **Output:** Forneça os dados extraídos ESTRITAMENTE conforme o schema JSON definido, incluindo TODOS os campos (os extraídos da imagem E os derivados por você a partir do contexto) para cada aplicação. Certifique-se de que o JSON seja válido.

    --- INÍCIO DAS INFORMAÇÕES DE CONTEXTO (UTILIZE PARA PREENCHER OS CAMPOS DERIVADOS) ---
    {CONTEXT_PLACEHOLDER}
    --- FIM DAS INFORMAÇÕES DE CONTEXTO ---
  PROMPT

  def initialize
    @api_key = ENV['GOOGLE_GEMINI_API_KEY']
    unless @api_key.present?
      Rails.logger.error "[GeminiApiServiceInitialize] CRITICAL: GOOGLE_GEMINI_API_KEY not found in environment variables. Service will be non-functional."
    end
  end

  def process_file(image_base64_data:, original_filename:, content_type:, known_active_vaccines: [], existing_shot_records: [], possible_doses_by_vaccine: {})
    unless @api_key.present?
      Rails.logger.error "[GeminiApiServiceProcessFile] Attempted to process file but API key is missing."
      return ServiceResponse.failure("Gemini API key not configured. Please check server environment.")
    end

    if image_base64_data.blank?
      Rails.logger.warn "[GeminiApiServiceProcessFile] image_base64_data is blank for file: #{original_filename}"
      return ServiceResponse.failure("Image data is empty and cannot be processed.")
    end

    supported_image_types = ['image/png', 'image/jpeg', 'image/webp', 'image/heic', 'image/heif']
    unless supported_image_types.include?(content_type.downcase.strip)
      Rails.logger.warn "[GeminiApiServiceProcessFile] Unsupported file content type: '#{content_type}' for file: #{original_filename}. Supported: #{supported_image_types.join(', ')}"
      return ServiceResponse.failure("Unsupported file type: '#{content_type}'. Please provide a supported image (PNG, JPEG, WEBP, HEIC, HEIF).")
    end

    begin
      # --- Construct the prompt with additional context ---
      context_block_string = ""
      context_parts = []

      if known_active_vaccines.is_a?(Array) && known_active_vaccines.any?
        vaccine_list_string = known_active_vaccines.map { |name| "- #{name}" }.join("\n")
        context_parts << <<~CONTEXT_PROMPT
        **Vacinas ativas conhecidas (geralmente da rede/clínica):**
        #{vaccine_list_string}
        CONTEXT_PROMPT
      else
        context_parts << "**Vacinas ativas conhecidas (geralmente da rede/clínica):** Nenhuma informação fornecida."
      end

      # <<<< NEW: Add dose context to the prompt
      if possible_doses_by_vaccine.is_a?(Hash) && possible_doses_by_vaccine.any?
        dose_list_string = possible_doses_by_vaccine.map do |vaccine_name, doses|
          "- #{vaccine_name}: [#{doses.join(', ')}]"
        end.join("\n")
        context_parts << <<~DOSE_CONTEXT_PROMPT
        **Doses Possíveis por Vacina:**
        #{dose_list_string}
        DOSE_CONTEXT_PROMPT
      else
        context_parts << "**Doses Possíveis por Vacina:** Nenhuma informação fornecida."
      end
      # <<<< END NEW: Add dose context to the prompt

      if existing_shot_records.is_a?(Array) && existing_shot_records.any?
        shots_summary = existing_shot_records.map do |shot|
          name = shot[:vaccine_name] || DEFAULT_VALUE_FOR_MISSING_FIELD
          date = shot[:application_date] || DEFAULT_VALUE_FOR_MISSING_FIELD
          manu = shot[:manufacturer] || DEFAULT_VALUE_FOR_MISSING_FIELD
          batch = shot[:batch] || DEFAULT_VALUE_FOR_MISSING_FIELD
          dose = shot[:dose] || DEFAULT_VALUE_FOR_MISSING_FIELD
          "- Vacina: #{name}, Data: #{date}, Lote: #{batch}, Fabricante: #{manu}, Dose: #{dose}"
        end.join("\n")
        context_parts << <<~SHOT_CONTEXT_PROMPT
        **Registros de vacinas existentes para este paciente:**
        #{shots_summary}
        SHOT_CONTEXT_PROMPT
      else
        context_parts << "**Registros de vacinas existentes para este paciente:** Nenhum registro prévio fornecido."
      end
      
      context_block_string = context_parts.join("\n\n")
      current_prompt = VACCINATION_CARD_PROMPT.sub("{CONTEXT_PLACEHOLDER}", context_block_string)
      
      Rails.logger.info "[GeminiApiServiceProcessFile] Prompt constructed with contextual information for Gemini."
      Rails.logger.debug "[GeminiApiServiceProcessFile] Full prompt for Gemini: #{current_prompt}" # For debugging

      # --- Prepare the request body (using your tested and confirmed approach) ---
      request_body_hash = {
        contents: [{
          parts: [
            { text: current_prompt },
            { inline_data: {
                mime_type: content_type,
                data: image_base64_data
              }
            }
          ]
        }],
        generation_config: {
          temperature: 0.2, # Lowered for more deterministic JSON based on schema
          response_mime_type: "application/json",
          response_schema: VACCINATION_CARD_DATA_SCHEMA
        }
      }

      request_body_json_string = request_body_hash.to_json
      total_request_size_bytes = request_body_json_string.bytesize

      Rails.logger.info "[GeminiApiServiceProcessFile] Original filename: #{original_filename}. Total request JSON size: #{total_request_size_bytes} bytes."

      if total_request_size_bytes > MAX_REQUEST_SIZE_BYTES
        error_message = "The file data for '#{original_filename}' is too large to process. Total request size (#{format('%.2f', total_request_size_bytes / (1024.0*1024.0))} MB) exceeds the #{MAX_REQUEST_SIZE_BYTES / (1024.0*1024.0)} MB limit."
        Rails.logger.error "[GeminiApiServiceProcessFile] #{error_message}"
        return ServiceResponse.failure(error_message)
      end

      Rails.logger.info "[GeminiApiServiceProcessFile] Processing '#{original_filename}' with Gemini model '#{GEMINI_MODEL_IDENTIFIER}'."

      # --- Net::HTTP Call (Your tested and working logic) ---
      uri_string = "#{GEMINI_API_BASE_URL}/#{GEMINI_MODEL_IDENTIFIER}:generateContent?key=#{@api_key}"
      uri = URI.parse(uri_string)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      http.read_timeout = 120
      http.open_timeout = 30

      request = Net::HTTP::Post.new(uri.request_uri)
      request['Content-Type'] = 'application/json'
      request.body = request_body_json_string

      response = http.request(request)
      Rails.logger.info "[GeminiApiServiceProcessFile] Received HTTP status: #{response.code} for file: #{original_filename}"

      unless response.is_a?(Net::HTTPSuccess)
        error_message = "Gemini API HTTP Error: #{response.code} #{response.message}"
        response_body_for_error = response.body.to_s.truncate(500)
        begin
          error_details = JSON.parse(response.body)
          error_message += " - Details: #{error_details.dig('error', 'message') || response_body_for_error}"
        rescue JSON::ParserError
          error_message += " - Body: #{response_body_for_error}"
        end
        Rails.logger.error "[GeminiApiServiceProcessFile] #{error_message} for file: #{original_filename}. Full Response Body (truncated): #{response.body.to_s.truncate(2000)}"
        return ServiceResponse.failure("Gemini API request failed with status #{response.code}.")
      end

      response_data = JSON.parse(response.body)
      Rails.logger.debug "[GeminiApiServiceProcessFile] Full Gemini Response Data: #{response_data.to_json}"

      candidates = response_data.dig("candidates")
      unless candidates.is_a?(Array) && candidates.first.is_a?(Hash)
        Rails.logger.error "[GeminiApiServiceProcessFile] No valid candidates array in Gemini response for file: #{original_filename}. Response: #{response.body.to_s.truncate(500)}"
        return ServiceResponse.failure("Gemini API did not return any valid candidates.")
      end
      
      first_candidate = candidates.first
      content_parts = first_candidate.dig("content", "parts")
      unless content_parts.is_a?(Array) && content_parts.first.is_a?(Hash)
        Rails.logger.error "[GeminiApiServiceProcessFile] No valid content parts in Gemini candidate for file: #{original_filename}. Candidate: #{first_candidate.to_json.truncate(500)}"
        return ServiceResponse.failure("Gemini API response malformed (no content/parts).")
      end

      part_data = content_parts.first
      parsed_llm_output = nil # Will hold the Hash from Gemini's JSON string

      # This parsing logic is based on your service being "tested and working"
      # with a model that returns JSON directly in the "text" field when response_schema is used.
      if part_data.key?("text") && part_data["text"].is_a?(String)
        json_string_from_text = part_data["text"]
        Rails.logger.info "[GeminiApiServiceProcessFile] Received JSON as a string within a text part for file: #{original_filename}. Length: #{json_string_from_text.length}"
        cleaned_json_string = json_string_from_text.strip.gsub(/^```json\s*|\s*```$/, '').strip # Remove markdown fences
        if cleaned_json_string.blank?
            Rails.logger.error "[GeminiApiServiceProcessFile] Empty JSON string after cleaning for file: #{original_filename}. Original text: #{json_string_from_text}"
            return ServiceResponse.failure("Gemini returned an empty JSON string.")
        end
        parsed_llm_output = JSON.parse(cleaned_json_string)
      else
        Rails.logger.error "[GeminiApiServiceProcessFile] Unexpected structure in Gemini response part for file: #{original_filename}. Expected 'text' key. Got: #{part_data.inspect}. Full response: #{response.body.to_s.truncate(1000)}"
        return ServiceResponse.failure("Gemini API did not return data in the expected format (no text part).")
      end
      # --- End API Call and Initial Parsing ---


      # --- Post-processing: Ensure all schema fields (including derived ones) are present ---
      if parsed_llm_output.is_a?(Hash) && parsed_llm_output["vaccine_applications"].is_a?(Array)
        Rails.logger.info "[GeminiApiServicePostProcessing] Verifying schema adherence for #{parsed_llm_output["vaccine_applications"].count} applications from Gemini."
        
        # All keys we expect in each application object, including those Gemini should derive
        all_expected_keys_in_schema_item = VACCINATION_CARD_DATA_SCHEMA.dig(:properties, :vaccine_applications, :items, :properties).keys.map(&:to_s)

        final_applications = parsed_llm_output["vaccine_applications"].map do |gemini_app|
          unless gemini_app.is_a?(Hash)
            Rails.logger.warn "[GeminiApiServicePostProcessing] Skipping non-hash item from Gemini's vaccine_applications: #{gemini_app.inspect}"
            next nil
          end

          # Ensure all keys defined in our VACCINATION_CARD_DATA_SCHEMA (items.properties) are present
          # This includes both image-extracted and context-derived keys that Gemini was asked to fill.
          processed_app_data = {}
          all_expected_keys_in_schema_item.each do |key_string|
            if gemini_app.key?(key_string) && 
               (gemini_app[key_string].is_a?(String) ? !gemini_app[key_string].strip.empty? : !gemini_app[key_string].nil?)
              processed_app_data[key_string] = gemini_app[key_string]
            else
              # Defaulting logic for any field Gemini might have missed
              default_val = case key_string
                            when "is_existing_record" then false # Boolean default
                            else DEFAULT_VALUE_FOR_MISSING_FIELD
                            end
              Rails.logger.warn "[GeminiApiServicePostProcessing] Key '#{key_string}' was missing or blank from Gemini's output for an application. Defaulting to '#{default_val}'."
              processed_app_data[key_string] = default_val
            end
          end
          processed_app_data
        end.compact # Remove any nil items if skipping non-hash items

        final_data = { "vaccine_applications" => final_applications }
        Rails.logger.info "[GeminiApiServicePostProcessing] Schema adherence check and defaulting complete."
        ServiceResponse.success(final_data)
      else
        Rails.logger.error "[GeminiApiServicePostProcessing] Parsed LLM output structure issue: 'vaccine_applications' not an array or main output not a hash. Output: #{parsed_llm_output.to_json.truncate(500)}"
        ServiceResponse.failure("LLM output structure was invalid after parsing (expected vaccine_applications array).")
      end

    rescue JSON::ParserError => e
      current_parsed_string = defined?(cleaned_json_string) ? cleaned_json_string : (defined?(json_string_from_text) ? json_string_from_text : response&.body)
      Rails.logger.error "[GeminiApiServiceProcessFile] JSON::ParserError: #{e.message}. Last string attempted to parse (if available): #{current_parsed_string.to_s.truncate(1000)}"
      ServiceResponse.failure("Error parsing data from Gemini.")
    rescue Net::OpenTimeout, Net::ReadTimeout, SocketError => e
      Rails.logger.error "[GeminiApiServiceProcessFile] Network error: #{e.message}"
      ServiceResponse.failure("Network error while communicating with Gemini.")
    rescue StandardError => e
      Rails.logger.error "[GeminiApiServiceProcessFile] Unexpected error: #{e.message}\n#{e.backtrace.first(10).join("\n")}"
      ServiceResponse.failure("An unexpected error occurred during Gemini processing.")
    end
  end
end

==================== ../netvacinas-frontend/src/components/UploadShots/index.tsx ====================

// netvacinas-frontend/src/components/UploadShots/index.tsx
import React, { useState } from "react";

import { Button as MuiButton } from "@mui/material"; // Using MUI Button

import { UploadShotsDialog } from "./dialog";

interface UploadShotsButtonProps {
  children: React.ReactNode; // To accept the button text like "Fazer upload..."
  // You can add other props here if needed, e.g., for styling the button
}

export const UploadShotsButton: React.FC<UploadShotsButtonProps> = ({
  children,
  ...buttonProps
}) => {
  const [dialogOpen, setDialogOpen] = useState(false);

  const handleOpenDialog = () => {
    setDialogOpen(true);
  };

  const handleCloseDialog = () => {
    setDialogOpen(false);
  };

  return (
    <>
      <MuiButton variant="contained" color="primary" onClick={handleOpenDialog} {...buttonProps}>
        {children}
      </MuiButton>
      <UploadShotsDialog open={dialogOpen} onClose={handleCloseDialog} />
    </>
  );
};


==================== ../netvacinas-frontend/src/lib/notification/index.tsx ====================

import { ReactNode, useCallback } from "react";

import { OptionsObject, useSnackbar, VariantType } from "notistack";

const useNotificationMessage = (variant: VariantType) => {
  const { enqueueSnackbar } = useSnackbar();
  return useCallback(
    (message: string | ReactNode, config: OptionsObject | undefined = {}) =>
      enqueueSnackbar(message, { variant, ...config }),
    [enqueueSnackbar, variant]
  );
};

export const useSuccessMessage = () => useNotificationMessage("success");

export const useErrorMessage = () => useNotificationMessage("error");


==================== ../netvacinas/app/graphql/graph/types/mutations/process_base64_file.rb ====================

# File Path: app/graphql/graph/types/mutations/process_base64_file.rb
require 'base64'
module Graph
  module Types
    module Mutations
      class ProcessBase64File < ::Graph::BaseMutation
        description "Uploads a Base64 encoded file for a patient, processes it with Gemini API (with context of active vaccines, existing shots, and possible doses), and returns the result."

        input_type Graph::Types::ProcessBase64FileInputType
        field :payload, Graph::Types::ProcessGeminiFilePayloadType, null: true

        def resolve(file_content_base64:, original_filename:, content_type:, patient_id:, **other_input_args)
          Rails.logger.info "[ProcessBase64File] Received request for patient_id: #{patient_id}, file: #{original_filename}"

          # --- Sanity Checks for input parameters ---
          unless file_content_base64.present? && original_filename.present? && content_type.present?
            missing_fields = []
            missing_fields << "file content" unless file_content_base64.present?
            missing_fields << "original filename" unless original_filename.present?
            missing_fields << "content type" unless content_type.present?
            error_message = "Missing required fields: #{missing_fields.join(', ')}."
            Rails.logger.warn "[ProcessBase64File] #{error_message} for patient_id: #{patient_id}"
            return { payload: { success: false, gemini_response: nil, errors: [error_message] } }
          end

          begin
            # --- 1. Prepare Base64 Content ---
            cleaned_base64_content = file_content_base64.sub(/^data:.+;base64,/, '')
            if cleaned_base64_content.blank?
              error_message = if file_content_base64.present?
                                "Invalid Base64 data: empty after removing data URI prefix."
                              else
                                "Base64 content is empty."
                              end
              Rails.logger.warn "[ProcessBase64File] #{error_message} for patient_id: #{patient_id}, original_filename: #{original_filename}"
              return { payload: { success: false, gemini_response: nil, errors: [error_message] } }
            end
            Rails.logger.debug "[ProcessBase64File] Prepared cleaned Base64 content for patient_id: #{patient_id}"
            # --- End Prepare Base64 Content ---

            # --- 2. Fetch Patient Context: Active Vaccines (Chain) & Existing Shots (Patient) ---
            actual_patient = find_node(patient_id)&.or_nil # Get Patient AR object (or nil if Nothing)

            active_vaccines = [] # Initialize default
            existing_shots_data = []  # Initialize default
            possible_doses_by_vaccine = {} # <<<< NEW: Initialize hash for dose context


            if actual_patient
              # Fetch full vaccine objects, eager loading the rule association
              active_vaccines = actual_patient.chain&.vaccines&.where(active: true) || []

              if active_vaccines.any?
                Rails.logger.info "[ProcessBase64File] Found #{active_vaccines.count} active vaccines for patient's chain."

                # Derive dose context from the vaccine objects
                active_vaccines.each do |vaccine|
                  # Use the confirmed `all_doses` method.
                  # Use safe navigation (&.) in case a rule exists but has no calendar.
                  all_doses = vaccine.rule&.calendar&.all_doses
                      
                  if all_doses.present?
                    possible_doses_by_vaccine[vaccine.name] = all_doses.map(&:label).uniq
                  end
                end
                Rails.logger.info "[ProcessBase64File] Fetched dose context for #{possible_doses_by_vaccine.keys.count} vaccines."
              end


              # Fetch existing shot records for THIS patient
              shots_to_process = actual_patient.shots.includes(
                :vaccine_manufacturer => [:vaccine, :manufacturer]
                # Consider adding more includes if your `shot.dose` method makes further DB calls
              )
              
              existing_shots_data = shots_to_process.map do |shot|
                current_vaccine_name = shot.vaccine_name
                current_manufacturer_name = shot.vaccine_manufacturer&.manufacturer&.name
                dose_object = shot.dose
                dose_display_text = if dose_object
                                      dose_object.try(:label) || dose_object.try(:name) || dose_object.to_s
                                    else
                                      shot.migrated_dose
                                    end
                {
                  vaccine_name: current_vaccine_name || "(Vacina não registrada no sistema)",
                  application_date: shot.date&.strftime('%d/%m/%Y') || "(Data não registrada no sistema)",
                  manufacturer: current_manufacturer_name || "(Fabricante não registrado no sistema)",
                  batch: shot.batch || "(Lote não registrado no sistema)",
                  dose: dose_display_text || "(Dose não registrada no sistema)"
                }
              end.compact

              if existing_shots_data.any?
                Rails.logger.info "[ProcessBase64File] Fetched #{existing_shots_data.count} existing shot records for patient #{patient_id}."
              else
                Rails.logger.info "[ProcessBase64File] No existing shot records found for patient #{patient_id}."
              end

            else # Patient not found or unwrapping resulted in nil
              if patient_maybe.is_a?(::Maybe::Nothing)
                Rails.logger.warn "[ProcessBase64File] Patient not found (Maybe::Nothing) with ID: #{patient_id}."
              elsif patient_maybe.is_a?(::Maybe::Some) # and or_nil returned nil
                Rails.logger.warn "[ProcessBase64File] Unwrapped patient from Maybe::Some but it resulted in nil for ID: #{patient_id}."
              else # find_node returned something else (e.g., direct nil, though Maybe() should prevent this)
                Rails.logger.error "[ProcessBase64File] find_node returned an unexpected value for patient ID #{patient_id}: #{patient_maybe.inspect}"
              end
              # active_vaccines and existing_shots_data remain [] as initialized
            end
            # --- End Data Fetching ---

            # --- Debugging Point (Uncomment if needed) ---
            # puts "DEBUG: [ProcessBase64File] actual_patient: #{actual_patient.inspect if actual_patient}"
            # puts "DEBUG: [ProcessBase64File] active_vaccines for prompt: #{active_vaccines.inspect}"
            # puts "DEBUG: [ProcessBase64File] existing_shots_data for prompt: #{existing_shots_data.inspect}"
            # binding.pry if defined?(binding) && Rails.env.development?
            # --- End Debugging Point ---

            # --- 3. Call Gemini Service ---
            gemini_service = ::GeminiApiService.new
            service_response = gemini_service.process_file(
              image_base64_data: cleaned_base64_content,
              original_filename: original_filename,
              content_type: content_type,
              known_active_vaccines: active_vaccines.map(&:name),
              existing_shot_records: existing_shots_data,
              possible_doses_by_vaccine: possible_doses_by_vaccine
            )

            # --- 4. Process Service Response ---
            if service_response.success?
              Rails.logger.info "[ProcessBase64File] Successfully processed file with Gemini for patient_id: #{patient_id}, file: #{original_filename}"
              { payload: { success: true, gemini_response: service_response.data, errors: nil } }
            else
              Rails.logger.warn "[ProcessBase64File] GeminiApiService failed for patient_id: #{patient_id}, file: #{original_filename}. Errors: #{service_response.errors.join(', ')}"
              { payload: { success: false, gemini_response: nil, errors: service_response.errors } }
            end

          rescue ArgumentError => e
            Rails.logger.error "[ProcessBase64File] Argument Error for patient #{patient_id}, mutation #{self.class.name}: #{e.message}"
            { payload: { success: false, gemini_response: nil, errors: ["Invalid argument during processing: #{e.message}"] } }
          rescue StandardError => e
            Rails.logger.error "[ProcessBase64File] Unexpected Processing Error for patient #{patient_id}, mutation #{self.class.name}: #{e.class.name} - #{e.message}\n#{e.backtrace.first(10).join("\n")}"
            { payload: { success: false, gemini_response: nil, errors: ["An unexpected error occurred: #{e.message}"] } }
          end
        end
      end
    end
  end
end

==================== ../netvacinas/app/graphql/graph/types/process_base64_file_input_type.rb ====================

module Graph
  module Types
    class ProcessBase64FileInputType < GraphQL::Schema::InputObject
      graphql_name "ProcessBase64FileInput" # Explicit name
      description "Attributes for processing a Base64 encoded file with Gemini"

      argument :file_content_base64, String, required: true,
                description: "The Base64 encoded content of the file."
      argument :original_filename, String, required: true,
                description: "The original filename (e.g., 'image.png')."
      argument :content_type, String, required: true,
                description: "The MIME type of the file (e.g., 'image/png')."
      argument :patient_id, ID, required: true, # Or String, depending on how you handle IDs
                description: "The ID of the patient associated with this vaccination card."
    end
  end
end

==================== ../netvacinas-frontend/src/data/queries.js ====================

import gql from "graphql-tag.macro";

export const pageInfoFragment = gql`
  fragment PageInfoFragment on PagedPageInfo {
    page
    totalPages
    hasNextPage
  }
`;

const campaignFragment = gql`
  fragment CampaignFragment on Campaign {
    id
    name
    date
    totalAmount
    institution {
      companyName
    }
    clinic {
      name
      logo {
        url
      }
    }
  }
`;

const campaignShotFragment = gql`
  fragment CampaignShotFragment on CampaignShot {
    id
    patient {
      name
      gender
      birthDate
    }
    vaccine {
      name
    }
    shotSite
    applicationDate
    applied
    value
  }
`;

const campaignShareFragment = gql`
  fragment CampaignShareFragment on CampaignShare {
    id
    code
    campaign {
      ...CampaignFragment
    }
  }
  ${campaignFragment}
`;

const priceFragment = gql`
  fragment PriceFragment on Price {
    __typename
    type: __typename
    price
    ... on HealthInsurancePrice {
      healthInsurance {
        name
        discount
      }
    }
  }
`;

const feeFragment = gql`
  fragment FeeFragment on Fee {
    fee {
      ... on FixedAmount {
        amount
      }
      ... on PercentAmount {
        percentage
      }
    }
  }
`;

const discountFragment = gql`
  fragment DiscountFragment on Discount {
    discount {
      ... on FixedAmount {
        amount
      }
      ... on PercentAmount {
        percentage
      }
    }
  }
`;

const validationErrorsFragment = gql`
  fragment ValidationErrorsFragment on ValidationErrors {
    errors {
      __typename
      type: __typename
      error
      ... on FieldValidationError {
        field
      }
    }
  }
`;

const orderFragment = gql`
  fragment OrderFragment on Order {
    __typename
    type: __typename
    id
    date
    total
    vaccineBundle {
      name
    }
    fees {
      ...FeeFragment
    }
    discounts {
      ...DiscountFragment
    }
    payments {
      __typename
      type: __typename
      id
      amount
      installments
      method {
        id
        label
        maxInstallments
      }
    }
    items {
      __typename
      type: __typename
      id
      price
      fees {
        ...FeeFragment
      }
      discounts {
        ...DiscountFragment
      }
      total
      invoiceItemDescription
      ... on VaccineOrderItem {
        shot {
          id
          date
          vaccine {
            id
            name
          }
          manufacturer {
            id
            name
          }
          patient {
            id
            name
            birthDate
          }
        }
      }
    }
    ... on PaidOrder {
      invoiceRecipientSuggestions {
        name
        email
        cpf
        phoneNumber
        address
        number
        complement
        district
        city
        cityCode
        state
        zipCode
        ... on PatientInvoiceRecipientSuggestion {
          patient {
            id
            recipientId: id
          }
        }
      }
    }
  }
  ${feeFragment}
  ${discountFragment}
`;

const batchFragment = gql`
  fragment BatchFragment on VaccineBatch {
    __typename
    type: __typename
    id
    label
    expirationDate
    inventoryCount(inventoryDate: $inventoryDate) @include(if: $withInventoryCount)
    manufacturer {
      __typename
      type: __typename
      id
      name
      barcode
      availableCount: inventoryCount(inventoryDate: $inventoryDate)
        @include(if: $withInventoryCount)
      inventoryCount(inventoryDate: $inventoryDate, onlyAvailable: false)
        @include(if: $withInventoryCount)
    }
  }
`;

const doseFragment = gql`
  fragment DoseFragment on Dose {
    __typename
    type: __typename
    id
    label
  }
`;

const vaccineFragment = gql`
  fragment VaccineFragment on Vaccine {
    __typename
    type: __typename
    id
    name
    price(clinicId: $clinicId) @include(if: $withPrice)
    prices(patientId: $patientId, clinicId: $clinicId) @include(if: $withPrices) {
      ...PriceFragment
    }
    inventoryCount(inventoryDate: $inventoryDate, clinicId: $clinicId, onlyAvailable: false)
      @include(if: $withInventoryCount)
    availableCount: inventoryCount(inventoryDate: $inventoryDate, clinicId: $clinicId)
      @include(if: $withInventoryCount)
    discounts(patientId: $patientId) @include(if: $withDiscounts) {
      ...DiscountFragment
    }
    fees(patientId: $patientId) @include(if: $withFees) {
      ...FeeFragment
    }
    doses(patientId: $patientId) @include(if: $withDoses) {
      ...DoseFragment
      shot {
        type: __typename
        id
        date
      }
    }
    applicationSites(clinicId: $clinicId) @include(if: $withApplicationSites) {
      id
      label
    }
    applicationMethods @include(if: $withApplicationMethods) {
      id
      label
    }
    manufacturers @include(if: $withManufacturers) {
      __typename
      type: __typename
      id
      name
      barcode
      inventoryCount(inventoryDate: $inventoryDate, clinicId: $clinicId, onlyAvailable: false)
        @include(if: $withInventoryCount)
      availableCount: inventoryCount(inventoryDate: $inventoryDate, clinicId: $clinicId)
        @include(if: $withInventoryCount)
      batches(
        inventoryDate: $inventoryDate
        withoutInventory: $withoutInventoryBatches
        withoutInventoryCount: $withoutInventoryCountBatches
        clinicId: $clinicId
      ) @include(if: $withBatches) {
        ...BatchFragment
      }
      reservable(inventoryDate: $inventoryDate, clinicId: $clinicId) @include(if: $withReservable)
    }
    batches(
      inventoryDate: $inventoryDate
      withoutInventory: $withoutInventoryBatches
      withoutInventoryCount: $withoutInventoryCountBatches
      clinicId: $clinicId
    ) @include(if: $withBatches) {
      ...BatchFragment
    }
    suggestedDose(patientId: $patientId, clinicId: $clinicId) @include(if: $withSuggestions) {
      ...DoseFragment
    }
    suggestedApplicationSite(clinicId: $clinicId) @include(if: $withSuggestions) {
      id
      label
    }
    reservable(inventoryDate: $inventoryDate, clinicId: $clinicId) @include(if: $withReservable)
    sipniSynchronizable
    ongoingCampaign
  }
  ${batchFragment}
  ${priceFragment}
  ${discountFragment}
  ${feeFragment}
  ${doseFragment}
`;

const applierFragment = gql`
  fragment ApplierFragment on Applier {
    __typename
    type: __typename
    id
    name
    coren
  }
`;

const shotFragment = gql`
  fragment ShotFragment on VaccineShot {
    __typename
    type: __typename
    id
    date
    patient @include(if: $withPatient) {
      id
      name
    }
    vaccine @include(if: $withVaccine) {
      id
      name
      inventoryCount
    }
    batch @include(if: $withBatch)
    dose @include(if: $withDose) {
      id
      label
    }
    observations
    ... on InternalVaccineShot {
      manufacturer @include(if: $withManufacturer) {
        id
        name
      }
      homeService
      appointmentResponsibleApplier @include(if: $withAppointmentApplier) {
        id
        name
      }
    }
    ... on ScheduledShot {
      orderItem {
        id
      }
      order {
        id
      }
      reserved
      fullPriceWithPreviousShots
    }
    ... on PendingShot {
      reserved
      fullPriceWithPreviousShots
    }
    ... on Payable {
      paid: isPaymentStatus(status: PAID)
      paying: isPaymentStatus(status: PAYING)
      payable
      chargedPrice
    }
  }
`;

const invoiceItemFragment = gql`
  fragment InvoiceItemFragment on InvoiceItem {
    ... on VaccineOrderItemInvoiceItem {
      orderItem {
        id
      }
    }
    ... on CampaignInvoiceItem {
      campaign {
        id
      }
    }
    ... on CampaignShotInvoiceItem {
      campaignShot {
        id
      }
    }
  }
`;

const appointmentFragment = gql`
  fragment AppointmentFragment on Appointment {
    __typename
    type: __typename
    id
    labels
    label
    date
    createdAt
    service
    time
    applier {
      id
      name
    }
    source
    editable
    clinic {
      id
      name
    }
    patients {
      id
      name
    }
  }
`;

const externalAppointmentFragment = gql`
  fragment ExternalAppointmentFragment on ExternalAppointment {
    client {
      name
      cpf
      email
      phoneNumber
    }
    address {
      street
      number
      complement
      district
      city
      state
      zipCode
    }
    fees {
      ...FeeFragment
    }
    discounts {
      ...DiscountFragment
    }
    products {
      __typename
      type: __typename
      id
      bundleName
      ... on Payable {
        orderItem {
          __typename
          type: __typename
          id
          price
          fees {
            ...FeeFragment
          }
          discounts {
            ...DiscountFragment
          }
          total
        }
        chargedPrice
        refundable
        processing: isPaymentStatus(status: PROCESSING)
        paid: isPaymentStatus(status: PAID)
      }
      ... on ExternalAppointmentVaccineProduct {
        vaccine {
          __typename
          type: __typename
          id
          name
        }
        patient {
          __typename
          type: __typename
          id
          name
          birthDate
          phoneNumber
        }
        shot {
          __typename
          type: __typename
          id
          date
          manufacturer {
            id
            name
          }
          dose {
            label
          }
          ... on ScheduledShot {
            reserved
            removable
          }
          ... on PendingShot {
            reserved
            removable
          }
          ... on AppliedShot {
            removable
          }
        }
      }
    }
    ... on ApprovedExternalAppointment {
      order {
        ...OrderFragment
      }
      paymentUrl
      expired
      refundable
      paid
    }
    ... on Appointment {
      spots {
        date
        schedule {
          time
          available
        }
      }
    }
  }
  ${orderFragment}
`;

const internalAppointmentFragment = gql`
  fragment InternalAppointmentFragment on InternalAppointment {
    paid
    observations
    shots {
      __typename
      type: __typename
      id
      date
      patient {
        id
        name
        birthDate
        phoneNumber
        address {
          address
          number
          complement
          district
          city
          state
        }
      }
      vaccine {
        id
        name
        manufacturers {
          id
          name
        }
      }
      dose {
        label
      }
      paid
      removable
      ... on InternalVaccineShot {
        manufacturer {
          id
          name
        }
      }
      ... on ScheduledShot {
        manufacturer {
          id
          name
        }
        reserved
      }
    }
  }
`;

export const fullAppointmentFragment = gql`
  fragment FullAppointmentFragment on Appointment {
    __typename
    type: __typename
    ...AppointmentFragment
    ...InternalAppointmentFragment
    ...ExternalAppointmentFragment
  }
  ${appointmentFragment}
  ${internalAppointmentFragment}
  ${externalAppointmentFragment}
`;

const appointmentBlockFragment = gql`
  fragment AppointmentBlockFragment on AppointmentBlock {
    __typename
    type: __typename
    id
    clinic {
      id
      name
    }
    date
    service
    time
    recurrent
    comment
  }
`;

const unavailableInInventoryErrorFragment = gql`
  fragment UnavailableInInventoryErrorFragment on UnavailableInInventoryError {
    __typename
    type: __typename
    field
  }
`;

const patientHistoryFragment = gql`
  fragment PatientHistoryFragment on PatientHistory {
    id
    date
    description
    patientId
    responsable
    attachments {
      name
      url
    }
  }
`;

export const appliersQuery = gql`
  query Appliers($clinicId: ID) {
    appliers(clinicId: $clinicId) {
      ...ApplierFragment
    }
  }
  ${applierFragment}
`;

export const vaccineListQuery = gql`
  query VaccineListNoBatch(
    $patientId: ID!
    $clinicId: ID
    $inventoryDate: LocalDate!
    $withPrice: Boolean!
    $withPrices: Boolean!
    $withInventoryCount: Boolean!
    $withDiscounts: Boolean!
    $withFees: Boolean!
    $withDoses: Boolean!
    $withApplicationSites: Boolean!
    $withApplicationMethods: Boolean!
    $withManufacturers: Boolean!
    $withBatches: Boolean!
    $withSuggestions: Boolean!
    $withReservable: Boolean!
    $withoutInventoryBatches: Boolean!
    $withoutInventoryCountBatches: Boolean!
  ) {
    vaccines {
      ...VaccineFragment
    }
  }
  ${vaccineFragment}
`;

export const vaccineQuery = gql`
  query Vaccine(
    $vaccineId: ID!
    $patientId: ID!
    $clinicId: ID
    $inventoryDate: LocalDate!
    $withPrice: Boolean!
    $withPrices: Boolean!
    $withInventoryCount: Boolean!
    $withDiscounts: Boolean!
    $withFees: Boolean!
    $withDoses: Boolean!
    $withApplicationSites: Boolean!
    $withApplicationMethods: Boolean!
    $withManufacturers: Boolean!
    $withBatches: Boolean!
    $withSuggestions: Boolean!
    $withReservable: Boolean!
    $withoutInventoryBatches: Boolean!
    $withoutInventoryCountBatches: Boolean!
  ) {
    vaccine: node(id: $vaccineId) {
      ...VaccineFragment
    }
  }
  ${vaccineFragment}
`;

export const vaccineNoBatchQuery = gql`
  query VaccineNoBatch(
    $vaccineId: ID!
    $patientId: ID!
    $clinicId: ID
    $inventoryDate: LocalDate!
    $withPrice: Boolean!
    $withPrices: Boolean!
    $withInventoryCount: Boolean!
    $withDiscounts: Boolean!
    $withFees: Boolean!
    $withDoses: Boolean!
    $withApplicationSites: Boolean!
    $withApplicationMethods: Boolean!
    $withManufacturers: Boolean!
    $withBatches: Boolean!
    $withSuggestions: Boolean!
    $withReservable: Boolean!
    $withoutInventoryBatches: Boolean!
    $withoutInventoryCountBatches: Boolean!
  ) {
    vaccine: node(id: $vaccineId) {
      ...VaccineFragment
    }
  }
  ${vaccineFragment}
`;

export const shotQuery = gql`
  query Shot(
    $shotId: ID!
    $withVaccine: Boolean!
    $withManufacturer: Boolean!
    $withBatch: Boolean!
    $withDose: Boolean!
    $withPatient: Boolean!
    $withAppointmentApplier: Boolean!
  ) {
    shot: node(id: $shotId) {
      ...ShotFragment
    }
  }
  ${shotFragment}
`;

export const cityAutocompleteQuery = gql`
  query CityAutocomplete($name: String!) {
    cities(name: $name, take: 10) {
      id
      name
      state
    }
  }
`;

const healthInsuranceFragment = gql`
  fragment HealthInsuranceFragment on HealthInsurance {
    id
    name
  }
`;

export const healthInsurancesQuery = gql`
  query HealthInsurances {
    healthInsurances {
      ...HealthInsuranceFragment
    }
  }
  ${healthInsuranceFragment}
`;

const referrerFragment = gql`
  fragment ReferrerFragment on Referrer {
    id
    name
  }
`;

export const referrerAutocompleteQuery = gql`
  query ReferrerAutocomplete($name: String) {
    referrers(name: $name, take: 8) {
      id
      name
    }
  }
`;

const fullPatientProfileFragment = gql`
  fragment FullPatientProfileFragment on Patient {
    name
    sex
    birthDate
    birthPlace {
      id
      name
    }
    birthCountry
    motherName
    fatherName
    cpf
    rg
    cns
    active
    address {
      address
      number
      complement
      district
      city
      cityCode
      state
      zipCode
    }
    mobile
    phones
    email
    allowEmailNotificationsForNonImmunizedDiseases
    allowEmailNotificationsForCampaigns
    allowWhatsappNotifications
    healthInsurance {
      ...HealthInsuranceFragment
    }
    healthInsuranceCode
    referrer {
      ...ReferrerFragment
    }
    contractedDiseases {
      name
    }
    notes
  }
  ${healthInsuranceFragment}
  ${referrerFragment}
`;

export const patientFragment = gql`
  fragment PatientFragment on Patient {
    id
    name
    sex
    birthDate
    active
    age {
      description(format: SIMPLE)
    }
    profileCompleted
    ...FullPatientProfileFragment @include(if: $withFullProfile)
    shots @include(if: $withShots) {
      __typename
      type: __typename
      id
      date
      dose {
        ...DoseFragment
      }
      observations
      vaccine {
        id
        name
        rule {
          id
          name
        }
      }
      batch
      removable
      migrated
      patientAge {
        description(format: FULL)
      }
      ... on InternalVaccineShot {
        patientSituation
        patientAttendanceGroupCode
        applier {
          ...ApplierFragment
        }
        homeService
        vaccineBundle {
          id
          name
        }
        appointment {
          __typename
          type: __typename
          id
          source
          editable
          time
          ... on ExternalAppointment {
            products {
              id
            }
          }
        }
      }
      ... on ExternalShot {
        adverseReactions {
          date
          description
        }
      }
      ... on Payable {
        paid: isPaymentStatus(status: PAID)
        paying: isPaymentStatus(status: PAYING)
        processing: isPaymentStatus(status: PROCESSING)
        payable
        refundable
        chargedPrice
      }
      ... on AppliedShot {
        manufacturer {
          id
          name
        }
        debitedFromInventory
        adverseReactions {
          date
          description
        }
        applicationSite {
          label
        }
      }
      ... on PendingShot {
        manufacturer {
          id
          name
        }
        reserved
        queue {
          id
          name
        }
        applicationSite {
          label
        }
        fullPriceWithPreviousShots
      }
      ... on ScheduledShot {
        manufacturer {
          id
          name
        }
        reserved
        orderItem {
          id
        }
        order {
          id
        }
        fullPriceWithPreviousShots
      }
      ... on SuggestedShot {
        forPregnant
      }
    }
    nonImmunizedDiseases @include(if: $withNonImmunizedDiseases) {
      name
    }
  }
  ${applierFragment}
  ${fullPatientProfileFragment}
  ${doseFragment}
`;

export const patientQuery = gql`
  query Patient(
    $id: ID!
    $withShots: Boolean = false
    $withNonImmunizedDiseases: Boolean = false
    $withFullProfile: Boolean = false
  ) {
    patient: node(id: $id) {
      ...PatientFragment
    }
  }
  ${patientFragment}
`;

export const campaignQuery = gql`
  query Campaign($id: ID!) {
    campaign: node(id: $id) {
      ...CampaignFragment
    }
  }
  ${campaignFragment}
`;

export const campaignShareQuery = gql`
  query CampaignShare($campaignId: ID, $code: String) {
    campaignShare(campaignId: $campaignId, code: $code) {
      ...CampaignShareFragment
    }
  }
  ${campaignShareFragment}
`;

export const campaignShotsListQuery = gql`
  query CampaignShotsList($campaignId: ID!, $filters: CampaignShotsFilters) {
    campaignShots(campaignId: $campaignId, filters: $filters) {
      ...CampaignShotFragment
    }
  }
  ${campaignShotFragment}
`;

export const paginatedCampaignShotsListQuery = gql`
  query PaginatedCampaignShotsList(
    $campaignId: ID!
    $filters: CampaignShotsFilters
    $page: Int = 1
    $pageSize: Int = 12
  ) {
    campaignShots: paginatedCampaignShots(
      campaignId: $campaignId
      filters: $filters
      page: $page
      pageSize: $pageSize
    ) {
      pageInfo {
        ...PageInfoFragment
      }
      items {
        ...CampaignShotFragment
      }
    }
  }
  ${campaignShotFragment}
  ${pageInfoFragment}
`;

export const upsertCampaignShareMutation = gql`
  mutation UpsertCampaignShare($input: UpsertCampaignShareInput!) {
    result: upsertCampaignShare(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...CampaignShareFragment
    }
  }
  ${campaignShareFragment}
  ${validationErrorsFragment}
`;

export const upsertPatientMutation = gql`
  mutation UpsertPatient(
    $input: UpsertPatientInput!
    $withShots: Boolean = false
    $withNonImmunizedDiseases: Boolean = false
    $withFullProfile: Boolean = true
  ) {
    result: upsertPatient(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...PatientFragment
    }
  }
  ${patientFragment}
  ${validationErrorsFragment}
`;

export const upsertPatientHistoryMutation = gql`
  mutation UpsertPatientHistory($input: UpsertPatientHistoryInput!) {
    result: upsertPatientHistory(input: $input) {
      __typename
      ...PatientHistoryFragment
    }
  }
  ${patientHistoryFragment}
`;

export const diseasesQuery = gql`
  query DiseasesQuery {
    diseases {
      name
    }
  }
`;

export const vaccineRulesQuery = gql`
  query VaccineRulesQuery($onlyUsedRules: Boolean!) {
    vaccineRules(onlyUsedRules: $onlyUsedRules) {
      type: __typename
      ... on VaccineRule {
        id
        name
        susOnly
      }
      ... on VaccineGroup {
        id
        name
        rules {
          type: __typename
          id
          name
          susOnly
        }
      }
    }
  }
`;

export const completeOrderMutation = gql`
  mutation CompleteOrderMutation($input: CompleteOrderInput!) {
    result: completeOrder(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...OrderFragment
      ... on PaidOrder {
        externalAppointment {
          id
        }
      }
    }
  }
  ${orderFragment}
  ${validationErrorsFragment}
`;

export const addExternalShotMutation = gql`
  mutation AddExternalShotMutation($input: CreateExternalShotInput!) {
    result: createExternalShot(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on ExternalShot {
        id
        patient {
          id
        }
        dose {
          ...DoseFragment
          shot {
            type: __typename
            id
          }
        }
      }
    }
  }
  ${validationErrorsFragment}
  ${doseFragment}
`;

export const updateExternalShotMutation = gql`
  mutation UpdateExternalShotMutation($input: UpdateExternalShotInput!) {
    result: updateExternalShot(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on ExternalShot {
        id
        patient {
          id
        }
      }
    }
  }
  ${validationErrorsFragment}
`;

export const removeShotMutation = gql`
  mutation RemoveShotMutation($input: RemoveShotInput!) {
    result: removeShot(input: $input) {
      __typename
      type: __typename
      ... on ValidationError {
        error
      }
      ... on RemovedShot {
        shot {
          __typename
          type: __typename
          id
          patient {
            id
          }
          ... on InternalVaccineShot {
            vaccine {
              id
            }
          }
          ... on PendingShot {
            order {
              id
            }
          }
          ... on ScheduledShot {
            order {
              id
            }
          }
          ... on AppliedShot {
            order {
              id
            }
          }
        }
      }
    }
  }
`;

export const removeReserveFromShotMutation = gql`
  mutation RemoveReserveFromShotMutation($input: RemoveReserveFromShotInput!) {
    result: removeReserveFromShot(input: $input) {
      __typename
      type: __typename
      ... on ValidationError {
        error
      }
      ... on ScheduledShot {
        id
        vaccine {
          id
        }
        reserved
      }
      ... on PendingShot {
        id
        vaccine {
          id
        }
        reserved
      }
    }
  }
`;

export const addReserveToShotMutation = gql`
  mutation AddReserveToShotMutation($input: AddReserveToShotInput!) {
    result: addReserveToShot(input: $input) {
      __typename
      type: __typename
      ... on ValidationError {
        error
      }
      ... on ScheduledShot {
        id
        vaccine {
          id
        }
        reserved
      }
      ... on PendingShot {
        id
        vaccine {
          id
        }
        reserved
      }
      ... on UnavailableInInventoryForReservationError {
        message
      }
    }
  }
`;

export const addRetroactiveShotMutation = gql`
  mutation AddRetroactiveShotMutation($input: CreateRetroactiveShotInput!) {
    result: createRetroactiveShot(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...UnavailableInInventoryErrorFragment
      ... on AppliedShot {
        id
        date
        patient {
          id
        }
        vaccine {
          id
        }
        debitedFromInventory
      }
      ... on ScheduledShot {
        id
        patient {
          id
        }
        vaccine {
          id
        }
        reserved
      }
    }
  }
  ${validationErrorsFragment}
  ${unavailableInInventoryErrorFragment}
`;

export const createAppliedShotsMutation = gql`
  mutation CreateAppliedShotsMutation($input: CreateAppliedShotsInput!) {
    result: createAppliedShots(input: $input) {
      order {
        __typename
        type: __typename
        ...ValidationErrorsFragment
        ...OrderFragment
        ... on Order {
          clinic {
            id
            name
          }
        }
      }
      shots {
        __typename
        type: __typename
        ...ValidationErrorsFragment
        ... on AppliedShot {
          id
          date
          patient {
            id
          }
          vaccine {
            id
          }
        }
      }
    }
  }
  ${orderFragment}
  ${validationErrorsFragment}
`;

export const applyPendingShotMutation = gql`
  mutation ApplyPendingShot($input: ApplyPendingShotInput!) {
    result: applyPendingShot(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on AppliedShot {
        id
        date
        vaccine {
          __typename
          id
        }
        manufacturer {
          id
        }
        patient {
          id
        }
      }
      ... on InvalidSecurityCodeError {
        message
      }
    }
  }
  ${validationErrorsFragment}
`;

export const upsertUnappliedShotMutation = gql`
  mutation UpsertUnappliedShot($input: UpsertUnappliedShotInput!) {
    result: upsertUnappliedShot(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...UnavailableInInventoryErrorFragment
      ... on InternalVaccineShot {
        id
        date
        patient {
          id
        }
        vaccine {
          id
        }
        manufacturer {
          id
        }
        ... on PendingShot {
          queue {
            id
            name
          }
          applier {
            id
            name
          }
        }
      }
    }
  }
  ${validationErrorsFragment}
  ${unavailableInInventoryErrorFragment}
`;

export const updateAppliedShotMutation = gql`
  mutation UpdateAppliedShot($input: UpdateAppliedShotInput!) {
    result: updateAppliedShot(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on InternalVaccineShot {
        id
        date
        patient {
          id
        }
        vaccine {
          id
        }
        manufacturer {
          id
        }
      }
      ... on ShotNotFoundError {
        error
      }
      ... on ShotNotAppliedError {
        error
      }
    }
  }
  ${validationErrorsFragment}
`;

export const pendingPaymentsQuery = gql`
  query PendingPayments {
    pendingPayments {
      __typename
      type: __typename
      chargedPrice
      payableType
      patient {
        id
        name
        age {
          description(format: SIMPLE)
        }
      }
      ... on VaccineShot {
        id
        date
        vaccine {
          id
          name
        }
        dose {
          ...DoseFragment
        }
        ... on PendingShot {
          queue {
            id
            name
          }
        }
      }
      ... on NotPaidOrder {
        ...OrderFragment
      }
    }
  }
  ${orderFragment}
  ${doseFragment}
`;

export const paymentMethodsQuery = gql`
  query PaymentMethods($clinicId: ID) {
    result: paymentMethods(clinicId: $clinicId) {
      type: __typename
      id
      label
      maxInstallments
      selectable
    }
  }
`;

export const currentUserQuery = gql`
  query CurrentUser {
    result: currentUser {
      __typename
      type: __typename
      ... on InternalUser {
        id
        name
        coren
        suggestedClinic {
          id
          name
          logo {
            url
          }
        }
      }
    }
  }
`;

const vaccinePermissionsFragment = gql`
  fragment VaccinePermissionsFragment on Permission {
    canWriteVaccineName
    canWriteVaccineRule
    canWriteVaccinePrice
    canWriteVaccineActive
    canWriteVaccineSipniSync
    canWriteVaccineManufacturer
    canWriteVaccineManufacturerBarcode
    canWriteVaccineMinimumInInventory
    canWriteVaccineReplenishmentDays
    canWriteVaccineNextReplenishmentDate
    canWriteVaccineNcm
    canWriteVaccineCest
    canWriteVaccineGtin
    canWriteVaccineCstPis
    canWriteVaccineCstCofins
    canWriteVaccineIcmsOrigem
    canWriteVaccineClinicPrice
    canWriteVaccineClinicMinimumInInventory
    canWriteVaccineClinicReplenishmentDays
    canWriteVaccineClinicNextReplenishmentDate
  }
`;

export const currentUserPermissionsQuery = gql`
  query CurrentUserPermissions(
    $patientId: ID!
    $clinicId: ID
    $withPatientPermissions: Boolean!
    $withVaccinePermissions: Boolean = false
  ) {
    result: currentUser {
      __typename
      type: __typename
      ... on InternalUser {
        id
        permissions(clinicId: $clinicId) {
          canApplyShotBeforePayment
          canApplyShotWithoutBarcode
          canEditAppliedShot
          canCreateRetroactiveShot(withInventory: true)
          canCreateRetroactiveShotWithoutInventory: canCreateRetroactiveShot(withInventory: false)
          minRetroactiveShotDate(withInventory: true)
          minRetroactiveShotWithoutInventoryDate: minRetroactiveShotDate(withInventory: false)
          canGenerateInvoice
          permittedInvoiceTypes
          canViewPatient(patientId: $patientId) @include(if: $withPatientPermissions)
          canRemoveVaccineOnAppointment
          canViewSuggestions
          canSendBulkWhatsappMessages
          canEditPatientSensitiveData
          canRegisterBillingCreditCard
          canRegisterExpenses
          canAddCardBrand
          canManageVaccineBundles
          ...VaccinePermissionsFragment @include(if: $withVaccinePermissions)
        }
      }
      ... on PatientUser {
        patient {
          id
        }
        permissions(clinicId: $clinicId) {
          canViewPatient(patientId: $patientId) @include(if: $withPatientPermissions)
          canViewSuggestions
        }
      }
      ... on AnonymousUser {
        permissions(clinicId: $clinicId) {
          canViewPatient(patientId: $patientId) @include(if: $withPatientPermissions)
        }
      }
    }
  }
  ${vaccinePermissionsFragment}
`;

export const searchAddressByZipCodeQuery = gql`
  query SearchAddressByZipCode($vaccineId: Int!) {
    zipCodeSearch: searchAddressByZipCode(zipCode: $zipCode) @client {
      __typename
      type: __typename
      ... on InvalidZipCode {
        message
      }
      ... on Address {
        address
        complement
        district
        city
        cityCode
        state
        zipCode
      }
    }
  }
`;

export const generateInvoiceMutation = gql`
  mutation GenerateInvoice($input: GenerateInvoiceInput!) {
    result: generateInvoice(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on AlreadyGeneratedError {
        message
        items {
          ...InvoiceItemFragment
        }
      }
      ... on Invoice {
        id
        date
        status
        recipient {
          email
        }
        items {
          ...InvoiceItemFragment
        }
      }
    }
  }
  ${validationErrorsFragment}
  ${invoiceItemFragment}
`;

export const registerPublicPatientMutation = gql`
  mutation RegisterPublicPatient($input: RegisterPublicPatientInput!) {
    result: registerPublicPatient(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on PublicPatient {
        id
      }
    }
  }
  ${validationErrorsFragment}
`;

export const patientExistenceQuery = gql`
  query PatientExistence($name: String, $birthDate: Date, $cpf: CPF) {
    result: patientExistence(name: $name, birthDate: $birthDate, cpf: $cpf) {
      exists
    }
  }
`;

const queueFragment = gql`
  fragment QueueFragment on Queue {
    id
    name
    applier {
      __typename
      type: __typename
      id
    }
  }
`;

export const queuesQuery = gql`
  query Queues {
    result: queues {
      ...QueueFragment
    }
  }
  ${queueFragment}
`;

export const queuedShotsQuery = gql`
  query QueuedShots($startDate: LocalDate) {
    result: queuedShots(startDate: $startDate) {
      id
      date
      patient {
        id
        name
        age {
          description(format: SIMPLE)
        }
      }
      vaccine {
        id
        name
      }
      manufacturer {
        id
        name
      }
      dose {
        ...DoseFragment
      }
      queue {
        ...QueueFragment
      }
      homeService
      observations
    }
  }
  ${queueFragment}
  ${doseFragment}
`;

export const updateClinicMutation = gql`
  mutation UpdateClinicConfig($input: UpdateClinicConfigInput!) {
    result: updateClinicConfig(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on Clinic {
        id
        name
        cnes
        sipniCertificate {
          expirationDate
        }
        sipniApiConfig {
          ownerDocument
          apiId
        }
      }
    }
  }
  ${validationErrorsFragment}
`;

export const updateClinicVacinaEConfiaConfigMutation = gql`
  mutation UpdateClinicVacinaEConfiaConfig($input: UpdateClinicVacinaEConfiaConfigInput!) {
    result: updateClinicVacinaEConfiaConfig(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on VacinaEConfiaConfig {
        cnes
        unitId
        integrationCredentialsUsername
        integrationCredentialsPassword
      }
    }
  }
  ${validationErrorsFragment}
`;

export const clinicQuery = gql`
  query Clinic($id: ID!) {
    clinic: node(id: $id) {
      ... on Clinic {
        id
        name
        cnes
        sipniCertificate {
          expirationDate
        }
        sipniApiConfig {
          ownerDocument
          apiId
        }
        usesVacinaEConfia
        vacinaEConfiaConfig {
          cnes
          unitId
          integrationCredentialsUsername
          integrationCredentialsPassword
        }
      }
    }
  }
`;

export const clinicsQuery = gql`
  query Clinics {
    clinics {
      id
      name
    }
  }
`;

export const clinicSipniRiaEvidenceQuery = gql`
  query ClinicSipniRiaEvidence($id: ID!) {
    clinic: node(id: $id) {
      ... on Clinic {
        id
        sipniRiaEvidence {
          url
          status
          errorMessage
          timestamp
        }
      }
    }
  }
`;

export const appointmentListQuery = gql`
  query AppointmentList(
    $startDate: Date
    $endDate: Date
    $startCreatedAt: Date
    $endCreatedAt: Date
    $status: ExternalAppointmentStatus
    $notStatus: ExternalAppointmentStatus
    $service: AppointmentService
    $clientName: String
    $clientCpf: CPF
    $clientEmail: String
    $patientName: String
    $clinicId: ID
  ) {
    appointments(
      startDate: $startDate
      endDate: $endDate
      startCreatedAt: $startCreatedAt
      endCreatedAt: $endCreatedAt
      status: $status
      notStatus: $notStatus
      service: $service
      clientName: $clientName
      clientCpf: $clientCpf
      clientEmail: $clientEmail
      patientName: $patientName
      clinicId: $clinicId
    ) {
      ...AppointmentFragment
      ... on ApprovedExternalAppointment {
        paid
        paymentUrl
      }
      ... on ExternalAppointment {
        client {
          name
          cpf
          email
          phoneNumber
        }
      }
      ... on InternalAppointment {
        paid
      }
    }
  }
  ${appointmentFragment}
`;

export const paginatedExternalAppointmentListQuery = gql`
  query PaginatedExternalAppointmentList(
    $startDate: Date
    $endDate: Date
    $startCreatedAt: Date
    $endCreatedAt: Date
    $status: ExternalAppointmentStatus
    $notStatus: ExternalAppointmentStatus
    $service: AppointmentService
    $clientName: String
    $clientCpf: CPF
    $clientEmail: String
    $patientName: String
    $clinicId: ID
    $page: Int = 1
    $pageSize: Int = 40
  ) {
    appointments: paginatedExternalAppointments(
      startDate: $startDate
      endDate: $endDate
      startCreatedAt: $startCreatedAt
      endCreatedAt: $endCreatedAt
      status: $status
      notStatus: $notStatus
      service: $service
      clientName: $clientName
      clientCpf: $clientCpf
      clientEmail: $clientEmail
      patientName: $patientName
      clinicId: $clinicId
      page: $page
      pageSize: $pageSize
    ) {
      pageInfo {
        ...PageInfoFragment
      }
      items {
        ...AppointmentFragment
        ... on ApprovedExternalAppointment {
          paid
        }
        ... on ExternalAppointment {
          client {
            name
            cpf
            email
            phoneNumber
          }
        }
        ... on InternalAppointment {
          paid
        }
      }
    }
  }
  ${appointmentFragment}
  ${pageInfoFragment}
`;

export const appointmentQuery = gql`
  query AppointmentNoBatch($id: ID!) {
    appointment: node(id: $id) {
      ...FullAppointmentFragment
    }
  }
  ${fullAppointmentFragment}
`;

export const updateExternalAppointmentMutation = gql`
  mutation UpdateExternalAppointment($input: UpdateExternalAppointmentInput!) {
    result: updateExternalAppointment(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...FullAppointmentFragment
    }
  }
  ${fullAppointmentFragment}
  ${validationErrorsFragment}
`;

export const upsertInternalAppointmentMutation = gql`
  mutation UpsertInternalAppointment($input: UpsertInternalAppointmentInput!) {
    result: upsertInternalAppointment(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...UnavailableInInventoryErrorFragment
      ...FullAppointmentFragment
    }
  }
  ${fullAppointmentFragment}
  ${validationErrorsFragment}
  ${unavailableInInventoryErrorFragment}
`;

export const patientListQuery = gql`
  query PatientList(
    $withFullProfile: Boolean = false
    $withAge: Boolean = false
    $filters: PatientsFilters
    $take: Int
  ) {
    patients(take: $take, filters: $filters) {
      id
      name
      sex
      phones
      mobile
      profileCompleted
      ...FullPatientProfileFragment @include(if: $withFullProfile)
      age @include(if: $withAge) {
        description(format: SIMPLE)
      }
    }
  }
  ${fullPatientProfileFragment}
`;

export const externalAppointmentClientListQuery = gql`
  query AppointmentClientList($name: String!) {
    externalAppointmentClients(name: $name) {
      name
    }
  }
`;

export const removeAppointmentMutation = gql`
  mutation RemoveAppointmentMutation($input: RemoveAppointmentInput!) {
    result: removeAppointment(input: $input) {
      __typename
      type: __typename
      ... on ValidationError {
        error
      }
      ... on NotCancelledExternalAppointment {
        message
      }
      ... on RemovedAppointment {
        appointment {
          __typename
          type: __typename
          id
          ... on ExternalAppointment {
            products {
              ... on ExternalAppointmentVaccineProduct {
                shot {
                  vaccine {
                    id
                  }
                }
              }
            }
          }
          ... on InternalAppointment {
            shots {
              vaccine {
                id
              }
            }
          }
        }
      }
    }
  }
`;

export const appointmentBlockListQuery = gql`
  query AppointmentBlockQuery($startDate: Date, $endDate: Date) {
    appointmentBlocks(startDate: $startDate, endDate: $endDate) {
      ...AppointmentBlockFragment
    }
  }
  ${appointmentBlockFragment}
`;

export const appointmentBlockQuery = gql`
  query AppointmentBlock($id: ID!) {
    appointmentBlock: node(id: $id) {
      ...AppointmentBlockFragment
    }
  }
  ${appointmentBlockFragment}
`;

export const scheduledShotsWithoutAppointmentQuery = gql`
  query ScheduledShotsWithoutAppointmentQuery(
    $startDate: Date
    $endDate: Date
    $service: AppointmentService
  ) {
    scheduledShotsWithoutAppointment(startDate: $startDate, endDate: $endDate, service: $service) {
      __typename
      type: __typename
      id
      date
      patient {
        name
      }
      clinic {
        id
      }
      vaccine {
        id
        name
      }
      ... on ScheduledShot {
        homeService
      }
    }
  }
`;

export const createAppointmentBlockMutation = gql`
  mutation CreateAppointmentBlock($input: CreateAppointmentBlockInput!) {
    result: createAppointmentBlock(input: $input) {
      ...AppointmentBlockFragment
      ...ValidationErrorsFragment
    }
  }
  ${appointmentBlockFragment}
  ${validationErrorsFragment}
`;

export const updateAppointmentBlockMutation = gql`
  mutation UpdateAppointmentBlock($input: UpdateAppointmentBlockInput!) {
    result: updateAppointmentBlock(input: $input) {
      ...AppointmentBlockFragment
      ...ValidationErrorsFragment
    }
  }
  ${appointmentBlockFragment}
  ${validationErrorsFragment}
`;

export const removeAppointmentBlockMutation = gql`
  mutation RemoveAppointmentBlockMutation($input: RemoveAppointmentBlockInput!) {
    result: removeAppointmentBlock(input: $input) {
      appointmentBlock {
        ...AppointmentBlockFragment
      }
    }
  }
  ${appointmentBlockFragment}
`;

export const removePatientHistoryMutation = gql`
  mutation RemovePatientHistoryMutation($input: RemovePatientHistoryInput!) {
    removePatientHistory(input: $input) {
      success
      message
    }
  }
`;

export const clinicsSpotsQuery = gql`
  query ClinicsSpots($service: AppointmentService!, $dateRange: DateRange!) {
    result: clinics {
      id
      name
      attendingSpots(service: $service, dateRange: $dateRange) {
        date
        schedule {
          time
          available
          open
        }
      }
    }
  }
`;

export const updateUnpaidShotMutation = gql`
  mutation UpdateUnpaidShot($input: UpdateUnpaidShotInput!) {
    result: updateUnpaidShot(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ...UnavailableInInventoryErrorFragment
      ... on VaccineShot {
        id
        date
        vaccine {
          id
          name
        }
        batch
        ... on InternalVaccineShot {
          manufacturer {
            id
            name
          }
        }
        ... on PendingShot {
          reserved
        }
        ... on ScheduledShot {
          reserved
        }
        ... on Payable {
          chargedPrice
          paid: isPaymentStatus(status: PAID)
          paying: isPaymentStatus(status: PAYING)
          payable
        }
      }
    }
  }
  ${validationErrorsFragment}
  ${unavailableInInventoryErrorFragment}
`;

export const refundPayableMutation = gql`
  mutation RefundPayableMutation($input: RefundPayableInput!) {
    result: refundPayable(input: $input) {
      __typename
      type: __typename
      ... on ValidationError {
        error
      }
      ... on RefundedPayable {
        payable {
          __typename
          type: __typename
          paid: isPaymentStatus(status: PAID)
          paying: isPaymentStatus(status: PAYING)
          payable
          refundable
          chargedPrice
          ... on InternalVaccineShot {
            id
            appointment {
              __typename
              type: __typename
              id
            }
            ... on PendingShot {
              reserved
              removable
            }
            ... on ScheduledShot {
              removable
              reserved
              orderItem {
                id
              }
              order {
                id
              }
            }
            ... on AppliedShot {
              removable
            }
          }
          ... on ExternalAppointmentProduct {
            id
          }
        }
      }
    }
  }
`;

export const removeSuggestionMutation = gql`
  mutation RemoveSuggestionMutation($input: RemoveSuggestionInput!) {
    result: removeSuggestion(input: $input) {
      __typename
      type: __typename
      ... on ValidationError {
        error
      }
      ... on SuggestedShot {
        id
        patient {
          id
        }
      }
    }
  }
`;

export const moveShotsMutation = gql`
  mutation MoveShots($input: [MoveShotInput!]!) {
    results: moveShots(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on VaccineShot {
        id
        date
        patient {
          id
        }
      }
    }
  }
  ${validationErrorsFragment}
`;

export const patientAttendanceGroupsQuery = gql`
  query PatientAttendanceGroups {
    result: patientAttendanceGroups {
      code
      name
    }
  }
`;

export const patientHistoryListQuery = gql`
  query PatientHistory(
    $patientId: ID!
    $withShots: Boolean = true
    $withNonImmunizedDiseases: Boolean = false
    $withFullProfile: Boolean = false
  ) {
    patient: node(id: $patientId) {
      ...PatientFragment
    }
    patientHistories(patientId: $patientId) {
      ...PatientHistoryFragment
    }
    currentUser {
      __typename
      userType: __typename
      ... on InternalUser {
        name
      }
    }
  }
  ${patientFragment}
  ${patientHistoryFragment}
`;

export const userAccessesClinics = gql`
  query userAccessesClinics($id: ID!) {
    user(id: $id) {
      __typename
      ... on InternalUser {
        id
        name
        userAccesses {
          role
          clinic {
            id
          }
        }
      }
    }
  }
`;

export const currentChain = gql`
  query currentChain {
    currentChain {
      clinics {
        id
        name
      }
      roles {
        name
        value
      }
    }
  }
`;

export const updateUserClinicAccessMutation = gql`
  mutation UpdateUserClinicAccess($input: UpdateUserClinicAccessInput!) {
    result: updateUserClinicAccess(input: $input) {
      __typename
      type: __typename
      ...ValidationErrorsFragment
      ... on InternalUser {
        id
        name
      }
    }
  }
  ${validationErrorsFragment}
`;

export const PROCESS_BASE64_FILE_MUTATION = gql`
  mutation ProcessBase64File($input: ProcessBase64FileInput!) {
    processBase64File(input: $input) {
      payload {
        success
        geminiResponse
        errors
      }
    }
  }
`;

export const SAVE_EXTRACTED_VACCINE_APPLICATIONS_MUTATION = gql`
  mutation SaveExtractedVaccineApplications($input: SaveExtractedVaccineApplicationsInput!) {
    saveExtractedVaccineApplications(input: $input) {
      payload {
        overallSuccess
        processedApplications {
          inputIndex
          success
          shot {
            id
            # Add any other fields from ExternalShotType you might want to use later
            # date 
            # observations
            # batch
          }
          errors
        }
      }
    }
  }
`;


==================== ../netvacinas/app/graphql/graph/types/mutations/save_extracted_vaccine_applications.rb ====================

# File Path: app/graphql/graph/types/mutations/save_extracted_vaccine_applications.rb

# Observations and TODOs: (Retained from your original)
#
# 2. Robustness of find_manufacturer_by_name_or_alias: This is the main "TODO".
# If this consistently returns nil because Gemini's manufacturer_name strings don't exactly match your DB,
# then resolve_vaccine_manufacturer will often fall back to vaccine.default_manufacturer or the first available VaccineManufacturer.
# This might not always be what the user intends if Gemini extracted a specific manufacturer that just wasn't an exact string match.
#
# 3. Creation of new VaccineManufacturer records: VaccineManufacturer.find_or_create_by!(...) is convenient.
# Ensure that your VaccineManufacturer model doesn't have other validates_presence_of for attributes not provided in the find_or_create_by!
# call, or that those attributes have database defaults. If creation fails validation, it will raise ActiveRecord::RecordInvalid,
# which will be caught by the helper's rescue block, resolve_vaccine_manufacturer will return nil, and that application will error out.
# This is generally correct behavior.
#
# 4. SuggestUseCase Error Handling: created_shots_list.each { |s| SuggestUseCase.new.call(s.patient)
# rescue Rails.logger.error("Error calling SuggestUseCase for patient #{s.patient_id}") }
# This silently rescues any error from SuggestUseCase.new.call(s.patient) and just logs it.
# This prevents the whole mutation from failing if SuggestUseCase has an issue.
# This is often the desired behavior for non-critical side effects. Confirm this is the intent.

# Ensure necessary types are loaded
require_dependency 'graph/types/vaccine_shot_type'
require_dependency 'graph/types/local_date_type'
# If input/payload types were moved to separate files, ensure they are required or autoloaded.

module Graph
  module Types
    module Mutations
      class SaveExtractedVaccineApplications < ::Graph::BaseMutation
        description "Saves a list of extracted and user-confirmed vaccine applications as external shots for a patient. Attempts to save all valid applications and reports errors for failures."

        # === INPUT TYPES (Nested) ===
        class ExtractedApplicationInputType < GraphQL::Schema::InputObject
          graphql_name "ExtractedVaccineApplicationInput"
          description "Data for a single vaccine application to be saved."

          argument :vaccine_id, ID, required: true, description: "ID of the selected vaccine from the system's active list."
          argument :application_date, Graph::Types::LocalDateType, required: true, description: "Date of application (YYYY-MM-DD)."
          argument :dose_id, String, required: false, description: "The string/symbol ID of the selected dose (e.g., 'D1', 'U')."
          argument :manufacturer_name, String, required: false, description: "Name of the manufacturer (as extracted/edited by user)."
          argument :batch_number, String, required: false, description: "Batch number of the vaccine."
          argument :observations, String, required: false, description: "User notes or observations for this application (can include AI extracted dose info)."
        end

        class SaveApplicationsInputType < GraphQL::Schema::InputObject
          graphql_name "SaveExtractedVaccineApplicationsInput"
          argument :patient_id, ID, required: true, description: "ID of the patient."
          argument :applications, [ExtractedApplicationInputType], required: true,
                    description: "List of vaccine applications to save. Must not be empty."
        end

        input_type SaveApplicationsInputType

        # === PAYLOAD TYPE (Nested, with unique name) ===
        # ... (Payload types remain the same) ...
        class ProcessedApplicationResultType < GraphQL::Schema::Object
          graphql_name "ProcessedApplicationResult"
          description "Result for a single processed application attempt."

          field :input_index, Int, null: false, description: "Original 0-based index of the application in the input list."
          field :shot, Graph::Types::ExternalShotType, null: true,
                description: "The created shot record if this specific application was saved successfully."
          field :success, Boolean, null: false, description: "True if this specific application was saved successfully."
          field :errors, [String], null: true, description: "Errors specific to this application, if any."
        end

        class SaveUserRevisedVaccineApplicationsPayloadType < GraphQL::Schema::Object # Renamed payload
          graphql_name "SaveUserRevisedVaccineApplicationsPayload" # Unique GraphQL name
          description "Result of attempting to save extracted vaccine applications, indicating partial success if applicable."

          field :overall_success, Boolean, null: false,
                description: "True if ALL applications were saved successfully. False if ANY application failed."
          field :processed_applications, [ProcessedApplicationResultType], null: false,
                description: "List of results for each processed application attempt."
        end

        field :payload, SaveUserRevisedVaccineApplicationsPayloadType, null: false

        # === RESOLVE METHOD ===
        def resolve(patient_id:, applications:, **other_args_if_any)
          applications_attrs = applications
          Rails.logger.info "[SaveExtractedVaccineApplications] Attempting to save #{applications_attrs.try(:count) || 0} applications for patient_id: #{patient_id}."

          actual_patient = find_node(patient_id)&.or_nil
          unless actual_patient
            Rails.logger.warn "[SaveExtractedVaccineApplications] Patient not found with ID: #{patient_id}."
            failed_results = (applications_attrs || []).map.with_index do |_, index|
              { input_index: index, success: false, shot: nil, errors: ["Paciente não encontrado."] }
            end
            return { payload: { overall_success: false, processed_applications: failed_results.presence || [] } }
          end

          if applications_attrs.blank?
            Rails.logger.warn "[SaveExtractedVaccineApplications] No applications provided for patient_id: #{patient_id}."
            return { payload: { overall_success: false, processed_applications: [] } }
          end

          processed_results = []
          any_errors_occurred_in_batch = false

          applications_attrs.each_with_index do |app_input_hash, index|
            app_identifier_for_log = "App ##{index + 1} (VaccineID: #{app_input_hash[:vaccine_id]}, DoseID: #{app_input_hash[:dose_id]}) for patient #{patient_id}"
            Rails.logger.info "[SaveExtractedVaccineApplications] Processing #{app_identifier_for_log}"

            current_app_errors = []
            created_shot_for_this_app = nil

            begin
              # --- Resolve Vaccine ---
              vaccine = find_node(app_input_hash[:vaccine_id])&.or_nil
              unless vaccine.is_a?(::Vaccine) && vaccine.chain_id == current_chain.id && vaccine.active?
                current_app_errors << "Vacina inválida (ID: '#{app_input_hash[:vaccine_id]}'), não encontrada, inativa ou não pertence à cadeia correta."
                raise StandardError, "Vaccine validation failed for #{app_identifier_for_log}"
              end

               # --- Resolve Dose ---
              resolved_dose = nil
              if app_input_hash[:dose_id].present?
                dose_id_from_input = app_input_hash[:dose_id] # This is the raw string like "D1"

                if vaccine.rule&.calendar
                  # <<<< CORRECTED LOGIC >>>>
                  # 1. Get all possible dose objects for this vaccine's calendar.
                  all_possible_doses = vaccine.rule.calendar.all_doses

                  # 2. Find the specific dose by its ID within that array.
                  #    The Dose object's ID is likely a symbol, so we convert the input to a symbol.
                  resolved_dose = all_possible_doses.find { |dose| dose.id == dose_id_from_input.to_sym }
                end
                
                unless resolved_dose
                  current_app_errors << "Dose inválida (ID: '#{dose_id_from_input}') para a vacina '#{vaccine.name}'."
                  raise StandardError, "Dose validation failed for #{app_identifier_for_log}"
                end
              end

              # --- Resolve Manufacturer & VaccineManufacturer ---
              manufacturer_obj = nil
              if app_input_hash[:manufacturer_name].present? && app_input_hash[:manufacturer_name] != ::GeminiApiService::DEFAULT_VALUE_FOR_MISSING_FIELD
                manufacturer_obj = find_manufacturer_by_name_or_alias(app_input_hash[:manufacturer_name], current_chain)
              end
              vaccine_manufacturer = resolve_vaccine_manufacturer(vaccine, manufacturer_obj, current_chain)
              unless vaccine_manufacturer
                current_app_errors << "Não foi possível determinar/criar o produto Vacina/Fabricante para Vacina '#{vaccine.name}' com o fabricante fornecido '#{app_input_hash[:manufacturer_name]}'."
                raise StandardError, "VaccineManufacturer resolution failed for #{app_identifier_for_log}"
              end

              # --- Prepare Shot Attributes ---
              shot_attributes = {
                patient: actual_patient, clinic: current_clinic, status: Shot::Status::APPLIED,
                date: app_input_hash[:application_date], sale_date: app_input_hash[:application_date],
                vaccine_manufacturer: vaccine_manufacturer, batch: app_input_hash[:batch_number].presence,
                observations: app_input_hash[:observations].presence, registered_by: current_user,
                external: true,
                external_batch_and_manufacturer: format_external_batch_manufacturer(app_input_hash[:batch_number], app_input_hash[:manufacturer_name]),
                audit: { user: current_user, clinic: current_clinic },
                dose_id: resolved_dose&.id,
                skip_dose_validation: app_input_hash[:dose_id].blank?
              }

              shot_to_save = Shot.new(shot_attributes)

              if shot_to_save.save
                created_shot_for_this_app = shot_to_save
                Rails.logger.info "[SaveExtractedVaccineApplications] Saved Shot ID: #{shot_to_save.id} for #{app_identifier_for_log}"
                SuggestUseCase.new.call(shot_to_save.patient) rescue Rails.logger.error("[SaveExtractedVaccineApplications] Error SuggestUseCase for patient #{shot_to_save.patient_id}: #{$!.message}")
              else
                current_app_errors.concat(shot_to_save.errors.full_messages)
                Rails.logger.warn "[SaveExtractedVaccineApplications] Failed to save #{app_identifier_for_log}: #{current_app_errors.join(', ')}"
              end
            rescue StandardError => e
              Rails.logger.error "[SaveExtractedVaccineApplications] Error during pre-save processing for #{app_identifier_for_log}: #{e.class.name} - #{e.message}"
              current_app_errors << "Erro interno ao processar aplicação: #{e.message}" unless current_app_errors.any?
            end

            if current_app_errors.empty? && created_shot_for_this_app
              processed_results << { input_index: index, success: true, shot: created_shot_for_this_app, errors: nil }
            else
              processed_results << { input_index: index, success: false, shot: nil, errors: current_app_errors.presence || ["Falha desconhecida ao salvar esta aplicação."] }
              any_errors_occurred_in_batch = true
            end
          end

          final_payload = {
            overall_success: !any_errors_occurred_in_batch,
            processed_applications: processed_results
          }

          if any_errors_occurred_in_batch
            Rails.logger.warn "[SaveExtractedVaccineApplications] Completed patient_id: #{patient_id} with errors."
          else
            Rails.logger.info "[SaveExtractedVaccineApplications] All applications processed successfully for patient_id: #{patient_id}."
          end

          { payload: final_payload }

        rescue StandardError => e
          Rails.logger.error "[SaveExtractedVaccineApplications] CRITICAL UNEXPECTED error for patient_id: #{patient_id}. Error: #{e.class.name} - #{e.message}\n#{e.backtrace.first(10).join("\n")}"
          general_error_message = "Ocorreu um erro inesperado no servidor ao processar o lote: #{e.message}"
          failed_app_results = (applications_attrs || []).map.with_index do |_, index|
            { input_index: index, success: false, shot: nil, errors: [general_error_message] }
          end
          if failed_app_results.empty? && (applications_attrs.nil? || applications_attrs.blank?)
             failed_app_results = [{input_index: 0, success: false, shot: nil, errors: [general_error_message]}]
          end
          { payload: { overall_success: false, processed_applications: failed_app_results } }
        end

        private

        def find_manufacturer_by_name_or_alias(name_str, chain_arg)
          return nil if name_str.blank? || name_str == ::GeminiApiService::DEFAULT_VALUE_FOR_MISSING_FIELD
          # Rails.logger.debug "[FMANA] Searching for manufacturer name: '#{name_str}' in chain: #{chain_arg.id}"
          manufacturer = chain_arg.manufacturers.where("LOWER(name) = ?", name_str.downcase.strip).first
          # if manufacturer
          #   Rails.logger.debug "[FMANA] Found manufacturer: ID=#{manufacturer.id}, Name='#{manufacturer.name}'"
          # else
          #   Rails.logger.debug "[FMANA] Manufacturer NOT found by exact name: '#{name_str}'"
          # end
          manufacturer
        end

        def resolve_vaccine_manufacturer(vaccine, manufacturer_obj_from_find, chain_arg_passed_in)
          # Rails.logger.debug "[RVM] Input vaccine: ID=#{vaccine&.id}, Name='#{vaccine&.name}'"
          # Rails.logger.debug "[RVM] Input manufacturer_obj_from_find: #{manufacturer_obj_from_find.inspect} (Name: '#{manufacturer_obj_from_find&.name}')"
          # Rails.logger.debug "[RVM] Input chain_arg_passed_in: ID=#{chain_arg_passed_in&.id}, Name='#{chain_arg_passed_in&.name}'"

          return nil unless vaccine && chain_arg_passed_in

          target_mfr = manufacturer_obj_from_find
          if target_mfr.nil?
            default_mfr_candidate = vaccine.try(:default_manufacturer)
            # Rails.logger.debug "[RVM] vaccine.try(:default_manufacturer) returned: #{default_mfr_candidate.inspect} (Name: '#{default_mfr_candidate&.name}')"
            if default_mfr_candidate && default_mfr_candidate.name != ::Manufacturer::UNAVAILABLE_MANUFACTURER
              target_mfr = default_mfr_candidate
            end
          end
          # Rails.logger.debug "[RVM] After considering default, target_mfr is #{target_mfr.inspect} (Name: '#{target_mfr&.name}')"

          if target_mfr
            unless target_mfr.is_a?(::Manufacturer)
              Rails.logger.error "[RVMHelper] Invalid type for target_mfr (expected Manufacturer) for Vaccine '#{vaccine.name}'. Got #{target_mfr.class}."
              return nil
            end

            # Rails.logger.debug "[RVM] Attempting find_or_create_by! VM with vaccine_id: #{vaccine.id}, manufacturer_id: #{target_mfr.id}, chain_id: #{chain_arg_passed_in.id}"
            vm = ::VaccineManufacturer.find_or_create_by!(
              vaccine: vaccine,
              manufacturer: target_mfr,
              chain: chain_arg_passed_in # Use the correctly scoped chain object
            ) do |new_vm_being_initialized|
              log_chain_name = chain_arg_passed_in.respond_to?(:name) ? chain_arg_passed_in.name : "CHAIN_OBJECT_INVALID_OR_NAME_UNAVAILABLE"
              Rails.logger.info "[RVMHelper] Creating new VaccineManufacturer record for Vaccine: '#{vaccine.name}', Manufacturer: '#{target_mfr.name}', Chain: '#{log_chain_name}'."
            end
            # Rails.logger.debug "[RVM] Found or created VM: ID=#{vm&.id}. Its manufacturer is #{vm&.manufacturer&.name}. Returning VM."
            return vm
          else
            # Rails.logger.debug "[RVM] target_mfr was nil. Falling back to find existing, non-(ND) VM for vaccine '#{vaccine.name}' in chain '#{chain_arg_passed_in.name}'..."
            vm = vaccine.vaccine_manufacturers
                        .joins(:manufacturer)
                        .where(chain: chain_arg_passed_in)
                        .where.not(manufacturers: { name: ::Manufacturer::UNAVAILABLE_MANUFACTURER })
                        .first
            if vm
              # Rails.logger.debug "[RVM] Fallback found existing non-(ND) VM: ID=#{vm.id}, Mfr: '#{vm.manufacturer&.name}'. Returning VM."
              return vm
            else
              # Rails.logger.debug "[RVM] Fallback: No existing non-(ND) VM found for vaccine '#{vaccine.name}' in chain '#{chain_arg_passed_in.name}'. Returning nil."
              Rails.logger.warn "[RVMHelper] CRITICAL: Cannot resolve a specific VM for Vaccine '#{vaccine.name}'. No explicit, suitable default, or existing non-(ND) VM found in chain."
              return nil
            end
          end
        rescue ActiveRecord::RecordInvalid => e_invalid
          Rails.logger.error "[RVMHelper] ActiveRecord::RecordInvalid creating/finding VM for Vaccine '#{vaccine.name}', Mfr '#{target_mfr&.name}', Chain '#{chain_arg_passed_in&.name}': #{e_invalid.message}"
          return nil
        rescue StandardError => e # Catch-all for this helper method
          Rails.logger.error "[RVMHelper] Outer unexpected error in resolve_vaccine_manufacturer (Vaccine: '#{vaccine.name}'): #{e.class.name} - #{e.message}\n#{e.backtrace.first(5).join("\n")}"
          return nil
        end

        def format_external_batch_manufacturer(batch, manufacturer_name)
          parts = []
          parts << "Lote: #{batch}" if batch.present?
          actual_mfr_name = (manufacturer_name == ::GeminiApiService::DEFAULT_VALUE_FOR_MISSING_FIELD) ? nil : manufacturer_name
          parts << "Fab: #{actual_mfr_name}" if actual_mfr_name.present?
          parts.join(' / ').presence || ::GeminiApiService::DEFAULT_VALUE_FOR_MISSING_FIELD
        end

      end # End class
    end
  end
end

==================== ../netvacinas/spec/graphql/mutations/save_extracted_vaccine_applications_spec.rb ====================

# spec/graphql/mutations/save_extracted_vaccine_applications_spec.rb
require 'rails_helper'

RSpec.describe Graph::Types::Mutations::SaveExtractedVaccineApplications, type: :request do
  let(:mutation_query) do
    <<~GQL
      mutation($input: SaveExtractedVaccineApplicationsInput!) {
        saveExtractedVaccineApplications(input: $input) {
          payload {
            overallSuccess
            processedApplications {
              inputIndex
              success
              shot {
                id
                date
                dose { # We can now query the dose
                  id
                  label
                }
                observations
                batch # This field in ExternalShotType is configured to return external_batch_and_manufacturer
                vaccineManufacturer {
                  vaccine {
                    name
                  }
                  manufacturer {
                    name
                  }
                }
              }
              errors
            }
          }
        }
      }
    GQL
  end

  let!(:chain) { create(:chain) }
  let!(:clinic) { create(:clinic, chain: chain) }
  let!(:patient_record) { create(:patient, chain: chain, clinic: clinic) }
  
  let!(:patient_gql_type) { Graph::Schema.types["Patient"] }
  let!(:vaccine_gql_type) { Graph::Schema.types["Vaccine"] }
  let!(:dose_gql_type) { Graph::Schema.types["Dose"] } 
  let!(:external_shot_gql_type_name) { Graph::Types::ExternalShotType.graphql_name }

  let!(:vaccine1_record) { create(:vaccine, name: "TestVax1", chain: chain, active: true) }
  let!(:manufacturer1) { create(:manufacturer, name: "TestMfr1", chain: chain) }
  let!(:vm1) { create(:vaccine_manufacturer, vaccine: vaccine1_record, manufacturer: manufacturer1, chain: chain) }

  let!(:vaccine2_record) { create(:vaccine, name: "TestVax2", chain: chain, active: true) }
  let!(:manufacturer2) { create(:manufacturer, name: "TestMfr2", chain: chain) }
  let!(:vm2) { create(:vaccine_manufacturer, vaccine: vaccine2_record, manufacturer: manufacturer2, chain: chain) }

  let(:context_overrides) { {} }
  let(:mutation_context) { netvacinas_context({ current_chain: chain, current_clinic: clinic }.merge(context_overrides)) }

  def generate_custom_gql_id(object, type_definition)
    Graph::Schema.id_from_object(object, type_definition, mutation_context)
  end

  def expected_external_batch_manufacturer_string(batch, manufacturer_name)
    parts = []
    parts << "Lote: #{batch}" if batch.present?
    actual_mfr_name = (manufacturer_name == ::GeminiApiService::DEFAULT_VALUE_FOR_MISSING_FIELD || manufacturer_name.blank?) ? nil : manufacturer_name
    parts << "Fab: #{actual_mfr_name}" if actual_mfr_name.present?
    parts.join(' / ').presence || ::GeminiApiService::DEFAULT_VALUE_FOR_MISSING_FIELD
  end

  def perform_mutation(variables)
    result = Graph::Schema.execute(mutation_query, variables: variables, context: mutation_context).to_h
    # Uncomment for debugging:
    # if RSpec.current_example.metadata[:print_gql_result] || true # to print all
    #   puts "\n>>>>>>>> Raw GraphQL Result for: #{RSpec.current_example.full_description}"
    #   puts result.inspect
    #   puts ">>>>>>>>\n"
    # end
    result
  end

  describe "resolve" do
    before(:each) do
      @suggest_use_case_instance = instance_double(SuggestUseCase)
      allow(SuggestUseCase).to receive(:new).and_return(@suggest_use_case_instance)
      allow(@suggest_use_case_instance).to receive(:call).and_return(true)
    end

    context "when all applications are valid and processed successfully" do
      let(:application1_attrs) { { vaccineId: generate_custom_gql_id(vaccine1_record, vaccine_gql_type), applicationDate: "2024-01-15", manufacturerName: manufacturer1.name, batchNumber: "B001", observations: "App1 Obs" } }
      let(:application2_attrs) { { vaccineId: generate_custom_gql_id(vaccine2_record, vaccine_gql_type), applicationDate: "2024-02-20", manufacturerName: manufacturer2.name, batchNumber: "B002", observations: "App2 Obs" } }
      let(:mutation_input_vars) do
        { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [application1_attrs, application2_attrs] } }
      end

      it "returns overallSuccess true" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        expect(payload["overallSuccess"]).to be true
      end

      it "returns a successful result for each processed application" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        processed_apps = payload["processedApplications"]
        
        expect(processed_apps.count).to eq(2)
        
        app1_result = processed_apps.find { |r| r["inputIndex"] == 0 }
        expect(app1_result["success"]).to be true
        expect(app1_result["errors"]).to be_nil
        expect(app1_result["shot"]).to be_present
        expect(app1_result["shot"]["batch"]).to eq(expected_external_batch_manufacturer_string("B001", manufacturer1.name))

        app2_result = processed_apps.find { |r| r["inputIndex"] == 1 }
        expect(app2_result["success"]).to be true
        expect(app2_result["errors"]).to be_nil
        expect(app2_result["shot"]).to be_present
        expect(app2_result["shot"]["batch"]).to eq(expected_external_batch_manufacturer_string("B002", manufacturer2.name))
      end

      it "creates the correct number of Shot records" do
        expect { perform_mutation(mutation_input_vars) }.to change { Shot.count }.by(2)
      end

      it "persists the shots with correct attributes" do
        perform_mutation(mutation_input_vars)
        shot1 = Shot.joins(vaccine_manufacturer: :vaccine)
                    .find_by!(patient: patient_record, batch: "B001", vaccines: { name: "TestVax1" })
        shot2 = Shot.joins(vaccine_manufacturer: :vaccine)
                    .find_by!(patient: patient_record, batch: "B002", vaccines: { name: "TestVax2" })

        expect(shot1.vaccine_manufacturer.vaccine.name).to eq("TestVax1")
        expect(shot1.vaccine_manufacturer.manufacturer.name).to eq(manufacturer1.name)
        expect(shot1.date.to_date).to eq(Date.new(2024, 1, 15))
        expect(shot1.observations).to eq("App1 Obs")
        expect(shot1.external).to be true
        expect(shot1.status).to eq(Shot::Status::APPLIED)
        expect(shot1.registered_by).to eq(mutation_context[:current_user])
        expect(shot1.batch).to eq("B001")
        expect(shot1.external_batch_and_manufacturer).to eq(expected_external_batch_manufacturer_string("B001", manufacturer1.name))

        expect(shot2.vaccine_manufacturer.vaccine.name).to eq("TestVax2")
        expect(shot2.observations).to eq("App2 Obs")
        expect(shot2.date.to_date).to eq(Date.new(2024, 2, 20))
        expect(shot2.batch).to eq("B002")
        expect(shot2.external_batch_and_manufacturer).to eq(expected_external_batch_manufacturer_string("B002", manufacturer2.name))
      end

      it "returns the created shots in the payload with custom IDs" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        processed_apps = payload["processedApplications"]
        
        shot1_db = Shot.joins(vaccine_manufacturer: :vaccine).find_by!(patient: patient_record, batch: "B001", vaccines: { name: "TestVax1" })
        shot2_db = Shot.joins(vaccine_manufacturer: :vaccine).find_by!(patient: patient_record, batch: "B002", vaccines: { name: "TestVax2" })
        
        app1_shot_payload = processed_apps.find { |r| r["inputIndex"] == 0 }["shot"]
        expect(app1_shot_payload["id"]).to eq("#{external_shot_gql_type_name}-#{shot1_db.id}")

        app2_shot_payload = processed_apps.find { |r| r["inputIndex"] == 1 }["shot"]
        expect(app2_shot_payload["id"]).to eq("#{external_shot_gql_type_name}-#{shot2_db.id}")
      end

      it "calls SuggestUseCase for the patient of each created shot" do
        perform_mutation(mutation_input_vars)
        expect(@suggest_use_case_instance).to have_received(:call).with(patient_record).twice
      end
    end

    context "when one application fails (e.g., invalid vaccineId) and others succeed" do
      let(:valid_app1_attrs) { { vaccineId: generate_custom_gql_id(vaccine1_record, vaccine_gql_type), applicationDate: "2024-03-01", manufacturerName: manufacturer1.name, batchNumber: "B003_PARTIAL" } }
      let(:invalid_app_attrs) { { vaccineId: "#{vaccine_gql_type.graphql_name}-invalid999", applicationDate: "2024-03-10", manufacturerName: "AnyMfr" } }
      let(:valid_app2_attrs) { { vaccineId: generate_custom_gql_id(vaccine2_record, vaccine_gql_type), applicationDate: "2024-03-15", manufacturerName: manufacturer2.name, batchNumber: "B004_PARTIAL" } }
      let(:mutation_input_vars) do
        { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [valid_app1_attrs, invalid_app_attrs, valid_app2_attrs] } }
      end

      it "returns overallSuccess false" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        expect(payload["overallSuccess"]).to be false
      end

      it "returns a result for each application, marking success/failure accordingly" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        processed_apps = payload["processedApplications"]
        
        expect(processed_apps.count).to eq(3)

        app1_result = processed_apps.find { |r| r["inputIndex"] == 0 }
        expect(app1_result["success"]).to be true
        expect(app1_result["shot"]).to be_present
        expect(app1_result["errors"]).to be_nil

        app2_result = processed_apps.find { |r| r["inputIndex"] == 1 }
        expect(app2_result["success"]).to be false
        expect(app2_result["shot"]).to be_nil
        expect(app2_result["errors"]).to include(match(/Vacina inválida.*ID: '#{invalid_app_attrs[:vaccineId]}'/))

        app3_result = processed_apps.find { |r| r["inputIndex"] == 2 }
        expect(app3_result["success"]).to be true
        expect(app3_result["shot"]).to be_present
        expect(app3_result["errors"]).to be_nil
      end

      it "creates Shot records only for the successful applications" do
        expect { perform_mutation(mutation_input_vars) }.to change { Shot.count }.by(2)
        expect(Shot.find_by(batch: "B003_PARTIAL", patient: patient_record)).to be_present
        expect(Shot.find_by(batch: "B004_PARTIAL", patient: patient_record)).to be_present
      end

      it "calls SuggestUseCase only for successfully created shots" do
        perform_mutation(mutation_input_vars)
        expect(@suggest_use_case_instance).to have_received(:call).with(patient_record).twice
      end
    end

    context "when all applications fail" do
      let(:invalid_vaccine_id1) { "#{vaccine_gql_type.graphql_name}-invalid777" }
      let(:invalid_vaccine_id2) { "#{vaccine_gql_type.graphql_name}-invalid888" }
      let(:mutation_input_vars) do
        { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
              { vaccineId: invalid_vaccine_id1, applicationDate: "2024-04-01" },
              { vaccineId: invalid_vaccine_id2, applicationDate: "2024-04-05" }
            ]}}
      end

      it "returns overallSuccess false" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        expect(payload["overallSuccess"]).to be false
      end

      it "returns a failed result for each application" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        processed_apps = payload["processedApplications"]
        expect(processed_apps.count).to eq(2)
        processed_apps.each_with_index do |app_result, i|
          expect(app_result["success"]).to be false
          expect(app_result["shot"]).to be_nil
          expect(app_result["errors"]).not_to be_empty
          expect(app_result["inputIndex"]).to eq(i)
        end
      end

      it "does not create any Shot records" do
        expect { perform_mutation(mutation_input_vars) }.not_to change { Shot.count }
      end

      it "does not call SuggestUseCase" do
        perform_mutation(mutation_input_vars)
        expect(@suggest_use_case_instance).not_to have_received(:call)
      end
    end
    
    context "when patient ID is invalid (as top-level failure)" do
      let(:mutation_input_vars) do
        { input: { patientId: "#{patient_gql_type.graphql_name}-invalid999", applications: [
              { vaccineId: generate_custom_gql_id(vaccine1_record, vaccine_gql_type), applicationDate: "2024-01-15" }
        ]}}
      end

      it "returns overallSuccess false and an error message for each application input" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        processed_apps = payload["processedApplications"]
        
        expect(payload["overallSuccess"]).to be false
        expect(processed_apps.count).to eq(1) 
        processed_apps.each do |app_result|
            expect(app_result["success"]).to be false
            expect(app_result["shot"]).to be_nil
            expect(app_result["errors"]).to include("Paciente não encontrado.")
        end
      end

      it "does not create any Shot records" do
        expect { perform_mutation(mutation_input_vars) }.not_to change { Shot.count }
      end
    end

    context "when applications input is an empty array" do
      let(:mutation_input_vars) do
        { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [] } }
      end

      it "returns overallSuccess false and an empty processedApplications array" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        
        expect(payload["overallSuccess"]).to be false
        expect(payload["processedApplications"]).to be_empty 
      end

      it "does not create any Shot records" do
        expect { perform_mutation(mutation_input_vars) }.not_to change { Shot.count }
      end
    end

    context "when handling manufacturer resolution scenarios" do
      let!(:manufacturer_for_default_tests) { create(:manufacturer, name: "DefaultMfrX", chain: chain) }
      let!(:manufacturer_for_other_vm_tests) { create(:manufacturer, name: "OtherMfrY", chain: chain) }
      let!(:manufacturer_nd_obj) { Manufacturer.find_by(name: Manufacturer::UNAVAILABLE_MANUFACTURER, chain: chain) || create(:manufacturer, name: Manufacturer::UNAVAILABLE_MANUFACTURER, chain: chain) }

      let!(:vaccine_for_default_mfr_test) { create(:vaccine, name: "VaxWithDefaultLogic", chain: chain, active: true) }
      let!(:vaccine_for_existing_vm_test) { create(:vaccine, name: "VaxForExistingVMTest", chain: chain, active: true) }
      let!(:vaccine_for_no_vm_resolve_test) { create(:vaccine, name: "VaxAloneForNoResolve", chain: chain, active: true) }
      
      before(:each) do
        # Setup for Scenario 2c
        VaccineManufacturer.where(vaccine: vaccine_for_existing_vm_test, chain: chain).destroy_all
        create(:vaccine_manufacturer, vaccine: vaccine_for_existing_vm_test, manufacturer: manufacturer_for_other_vm_tests, chain: chain)
        
        # Setup for Scenario 2d
        allow(vaccine_for_no_vm_resolve_test).to receive(:default_manufacturer).and_return(nil)
        VaccineManufacturer.where(vaccine: vaccine_for_no_vm_resolve_test, chain: chain)
                           .where.not(manufacturer: manufacturer_nd_obj) 
                           .destroy_all
      end

      context "Scenario 2a: manufacturerName is blank/default, and STUBBED vaccine.default_manufacturer is used" do
        let(:mutation_input_vars) do
          { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
            { vaccineId: generate_custom_gql_id(vaccine_for_default_mfr_test, vaccine_gql_type), applicationDate: "2024-06-01", manufacturerName: nil, batchNumber: "B_S2A_DEFAULT_MFR" }
          ]}}
        end

        before do 
          allow(Graph::Schema).to receive(:object_from_id).and_call_original
          allow(Graph::Schema).to receive(:object_from_id)
            .with(generate_custom_gql_id(vaccine_for_default_mfr_test, vaccine_gql_type), anything)
            .and_return(vaccine_for_default_mfr_test)
          allow(vaccine_for_default_mfr_test).to receive(:default_manufacturer).and_return(manufacturer_for_default_tests)
        end

        it "successfully saves the shot using the STUBBED vaccine's default manufacturer ('DefaultMfrX')" do
          expect { perform_mutation(mutation_input_vars) }.to change { Shot.count }.by(1)
          result = perform_mutation(mutation_input_vars) 
          payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
          
          expect(payload["overallSuccess"]).to be true
          app_result = payload.dig("processedApplications", 0)
          expect(app_result).not_to be_nil
          expect(app_result["success"]).to be true
          expect(app_result.dig("shot", "vaccineManufacturer", "manufacturer", "name")).to eq("DefaultMfrX")
          
          saved_shot = Shot.find_by!(batch: "B_S2A_DEFAULT_MFR", patient: patient_record)
          expect(saved_shot.vaccine_manufacturer.manufacturer.name).to eq("DefaultMfrX")
        end
      end

      context "Scenario 2b: manufacturerName provided but not found, STUBBED vaccine.default_manufacturer is used" do
        let(:mutation_input_vars) do
          { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
            { vaccineId: generate_custom_gql_id(vaccine_for_default_mfr_test, vaccine_gql_type), applicationDate: "2024-06-02", manufacturerName: "NonExistentMfrName", batchNumber: "B_S2B_NONEXIST_FALLBACK" }
          ]}}
        end
        
        before do 
          allow(Graph::Schema).to receive(:object_from_id).and_call_original
          allow(Graph::Schema).to receive(:object_from_id)
            .with(generate_custom_gql_id(vaccine_for_default_mfr_test, vaccine_gql_type), anything)
            .and_return(vaccine_for_default_mfr_test)
          allow(vaccine_for_default_mfr_test).to receive(:default_manufacturer).and_return(manufacturer_for_default_tests)
        end

        it "successfully saves using the STUBBED vaccine's default manufacturer ('DefaultMfrX')" do
          expect { perform_mutation(mutation_input_vars) }.to change { Shot.count }.by(1)
          result = perform_mutation(mutation_input_vars)
          payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
          expect(payload["overallSuccess"]).to be true
          app_result = payload.dig("processedApplications", 0)
          expect(app_result).not_to be_nil
          expect(app_result["success"]).to be true
          expect(app_result.dig("shot", "vaccineManufacturer", "manufacturer", "name")).to eq("DefaultMfrX")
          
          saved_shot = Shot.find_by!(batch: "B_S2B_NONEXIST_FALLBACK", patient: patient_record)
          expect(saved_shot.vaccine_manufacturer.manufacturer.name).to eq("DefaultMfrX")
        end
      end
      
      context "Scenario 2c: No manufacturerName, no default_manufacturer, but an existing VM for vaccine/chain is used" do
        let(:mutation_input_vars) do
          { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
            { vaccineId: generate_custom_gql_id(vaccine_for_existing_vm_test, vaccine_gql_type), applicationDate: "2024-06-03", manufacturerName: nil, batchNumber: "B_S2C_EXISTING_VM" }
          ]}}
        end

        before do
            allow(Graph::Schema).to receive(:object_from_id).and_call_original
            allow(Graph::Schema).to receive(:object_from_id)
              .with(generate_custom_gql_id(vaccine_for_existing_vm_test, vaccine_gql_type), anything)
              .and_return(vaccine_for_existing_vm_test)
            allow(vaccine_for_existing_vm_test).to receive(:default_manufacturer).and_return(nil)
        end

        it "successfully saves using the first available VaccineManufacturer ('OtherMfrY')" do
          expect { perform_mutation(mutation_input_vars) }.to change { Shot.count }.by(1)
          result = perform_mutation(mutation_input_vars)
          payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
          expect(payload["overallSuccess"]).to be true
          app_result = payload.dig("processedApplications", 0)
          expect(app_result).not_to be_nil
          expect(app_result["success"]).to be true
          expect(app_result.dig("shot", "vaccineManufacturer", "manufacturer", "name")).to eq("OtherMfrY")

          saved_shot = Shot.find_by!(batch: "B_S2C_EXISTING_VM", patient: patient_record)
          expect(saved_shot.vaccine_manufacturer.manufacturer.name).to eq("OtherMfrY")
        end
      end

      context "Scenario 2d: NO VaccineManufacturer can be resolved (no name, no default, no existing VM for this specific test vaccine)" do
        let(:mutation_input_vars) do
          { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
            { vaccineId: generate_custom_gql_id(vaccine_for_no_vm_resolve_test, vaccine_gql_type), applicationDate: "2024-06-04", manufacturerName: "UnknownOrNonExistent", batchNumber: "B_S2D_NO_VM_RESOLVE" }
          ]}}
        end

        before do
            allow(Graph::Schema).to receive(:object_from_id).and_call_original
            allow(Graph::Schema).to receive(:object_from_id)
              .with(generate_custom_gql_id(vaccine_for_no_vm_resolve_test, vaccine_gql_type), anything)
              .and_return(vaccine_for_no_vm_resolve_test)
            # :default_manufacturer is already stubbed to nil for vaccine_for_no_vm_resolve_test by the outer before block
        end

        it "fails to save the application and reports an error" do
          expect { perform_mutation(mutation_input_vars) }.not_to change { Shot.count }
          result = perform_mutation(mutation_input_vars)
          payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
          
          expect(payload["overallSuccess"]).to be false
          app_result = payload.dig("processedApplications", 0)
          expect(app_result).not_to be_nil
          expect(app_result["success"]).to be false
          expect(app_result["shot"]).to be_nil
          expect(app_result["errors"].first).to match(/Não foi possível determinar\/criar o produto Vacina\/Fabricante.*VaxAloneForNoResolve/)
        end
      end
    end

    context "when a shot model validation fails for one application" do
      let(:valid_app_attrs) { { vaccineId: generate_custom_gql_id(vaccine1_record, vaccine_gql_type), applicationDate: "2024-05-01", manufacturerName: manufacturer1.name, batchNumber: "VALID_BATCH_MODEL_FAIL", observations: "Valid App Obs" } }
      let(:app_to_fail_save_attrs) { { vaccineId: generate_custom_gql_id(vaccine2_record, vaccine_gql_type), applicationDate: "2024-05-05", manufacturerName: manufacturer2.name, batchNumber: "FAIL_BATCH_MODEL_FAIL", observations: "App to Fail Obs" } }
      let(:mutation_input_vars) do
        { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [valid_app_attrs, app_to_fail_save_attrs] } }
      end

      before do
        @failing_shot_double = instance_double(
          Shot,
          save: false, 
          errors: double("errors_double", full_messages: ["Mocked model validation error from double"]),
          patient: patient_record, 
          vaccine_manufacturer: vm2, 
          date: Graph::Types::LocalDateType.coerce_input(app_to_fail_save_attrs[:applicationDate], mutation_context),
          batch: app_to_fail_save_attrs[:batchNumber],
          observations: app_to_fail_save_attrs[:observations],
          external: true, 
          status: Shot::Status::APPLIED,
          registered_by: mutation_context[:current_user],
          external_batch_and_manufacturer: expected_external_batch_manufacturer_string(
            app_to_fail_save_attrs[:batchNumber], 
            app_to_fail_save_attrs[:manufacturerName]
          ),
          # Ensure all attributes expected by the Shot model for `new` are present or stubbed
          # if not covered by the attributes hash passed to `Shot.new` in the mutation.
          dose_id: nil, 
          skip_dose_validation: true 
        )
        allow(@failing_shot_double).to receive(:attributes=).with(anything) # Handles mass assignment
        allow(@failing_shot_double).to receive(:valid?).and_return(false) # Explicitly make it invalid

        allow(Shot).to receive(:new).and_call_original # Allow other :new calls to proceed
        allow(Shot).to receive(:new)
          .with(hash_including(batch: app_to_fail_save_attrs[:batchNumber])) # Match the failing shot's attributes
          .and_return(@failing_shot_double)
      end

      it "marks the specific application as failed with model errors" do
        result = perform_mutation(mutation_input_vars)
        payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
        expect(payload).not_to be_nil, "Payload was nil. GraphQL result: #{result.inspect}"
        processed_apps = payload["processedApplications"]

        expect(payload["overallSuccess"]).to be false
        
        successful_app_result = processed_apps.find { |r| r["inputIndex"] == 0 }
        expect(successful_app_result["success"]).to be true
        expect(successful_app_result["shot"]).to be_present
        # ===> UPDATED BATCH EXPECTATION for the successful shot's payload <===
        expect(successful_app_result["shot"]["batch"]).to eq(
          expected_external_batch_manufacturer_string(valid_app_attrs[:batchNumber], valid_app_attrs[:manufacturerName])
        )   
        expect(successful_app_result["errors"]).to be_nil

        failed_app_result = processed_apps.find { |r| r["inputIndex"] == 1 }
        expect(failed_app_result["success"]).to be false
        expect(failed_app_result["shot"]).to be_nil 
        expect(failed_app_result["errors"]).to include("Mocked model validation error from double")
      end

      it "only saves the valid shot" do
        initial_shot_count = Shot.count
        perform_mutation(mutation_input_vars)
        expect(Shot.count).to eq(initial_shot_count + 1)

        expect(Shot.find_by(batch: valid_app_attrs[:batchNumber])).to be_present
        expect(Shot.find_by(batch: app_to_fail_save_attrs[:batchNumber])).not_to be_present
      end
      
      it "calls SuggestUseCase only for the successfully saved shot" do
        perform_mutation(mutation_input_vars)
        expect(@suggest_use_case_instance).to have_received(:call).with(patient_record).once
      end
    end

    context "when handling specific manufacturer name inputs" do
      let!(:vaccine_regular) { create(:vaccine, name: "RegularVax", chain: chain, active: true) }
      let!(:mfr_real) { create(:manufacturer, name: "RealMfr", chain: chain) }
      let!(:mfr_nd) { Manufacturer.find_by(name: Manufacturer::UNAVAILABLE_MANUFACTURER, chain: chain) || create(:manufacturer, name: Manufacturer::UNAVAILABLE_MANUFACTURER, chain: chain) }

      before do
        # No default manufacturer for vaccine_regular for these specific tests
        allow(vaccine_regular).to receive(:default_manufacturer).and_return(nil)
        # Ensure no pre-existing VM for vaccine_regular and mfr_real unless intended by a specific test
        VaccineManufacturer.where(vaccine: vaccine_regular, manufacturer: mfr_real, chain: chain).destroy_all
      end

      context "when manufacturerName input is the (ND) placeholder string" do
        let(:mutation_input_vars) do
          { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
            { vaccineId: generate_custom_gql_id(vaccine_regular, vaccine_gql_type), applicationDate: "2024-07-01", 
              manufacturerName: ::GeminiApiService::DEFAULT_VALUE_FOR_MISSING_FIELD, # Input is "(Não especificado)"
              batchNumber: "B_ND_INPUT" }
          ]}}
        end

        it "attempts to use a fallback (e.g., existing non-ND VM or fails if none)" do
          # This test depends on whether a VM with (ND) manufacturer should be created or if it should always fallback.
          # Current resolve_vaccine_manufacturer logic:
          # 1. find_manufacturer_by_name_or_alias gets nil because name_str == DEFAULT_VALUE_FOR_MISSING_FIELD.
          # 2. target_mfr becomes nil.
          # 3. Falls back to finding an existing, non-(ND) VM. If none, returns nil.
          
          # Let's assume no other VM exists for vaccine_regular
          VaccineManufacturer.where(vaccine: vaccine_regular, chain: chain).destroy_all

          result = perform_mutation(mutation_input_vars)
          payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
          expect(payload["overallSuccess"]).to be false # Because VM resolution will fail
          app_result = payload.dig("processedApplications", 0)
          expect(app_result["success"]).to be false
          expect(app_result["errors"].first).to match(/Não foi possível determinar\/criar o produto Vacina\/Fabricante/)
        end
      end

      context "when manufacturerName input with leading/trailing spaces matches an existing manufacturer" do
        let(:mutation_input_vars) do
          { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
            { vaccineId: generate_custom_gql_id(vaccine_regular, vaccine_gql_type), applicationDate: "2024-07-02", 
              manufacturerName: " #{mfr_real.name} ", # Name with spaces
              batchNumber: "B_SPACES_MFR" }
          ]}}
        end
        
        it "finds the manufacturer and saves the shot" do
          # This relies on find_manufacturer_by_name_or_alias doing .strip
          expect { perform_mutation(mutation_input_vars) }.to change { Shot.count }.by(1)
          result = perform_mutation(mutation_input_vars)
          payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
          expect(payload["overallSuccess"]).to be true
          app_result = payload.dig("processedApplications", 0)
          expect(app_result["success"]).to be true
          expect(app_result.dig("shot", "vaccineManufacturer", "manufacturer", "name")).to eq(mfr_real.name)
        end
      end
      
      context "when a new VaccineManufacturer record needs to be created" do
        let(:mutation_input_vars) do
          { input: { patientId: generate_custom_gql_id(patient_record, patient_gql_type), applications: [
            { vaccineId: generate_custom_gql_id(vaccine_regular, vaccine_gql_type), applicationDate: "2024-07-03", 
              manufacturerName: mfr_real.name, # Valid, existing Manufacturer
              batchNumber: "B_NEW_VM" }
          ]}}
        end

        it "creates a new VaccineManufacturer and saves the shot" do
          # Ensure no VM for this combo exists beforehand
          VaccineManufacturer.where(vaccine: vaccine_regular, manufacturer: mfr_real, chain: chain).destroy_all

          expect { perform_mutation(mutation_input_vars) }.to change { VaccineManufacturer.count }.by(1)
            .and change { Shot.count }.by(1)
          
          result = perform_mutation(mutation_input_vars)
          payload = result.dig("data", "saveExtractedVaccineApplications", "payload")
          expect(payload["overallSuccess"]).to be true
          app_result = payload.dig("processedApplications", 0)
          expect(app_result["success"]).to be true
          expect(app_result.dig("shot", "vaccineManufacturer", "manufacturer", "name")).to eq(mfr_real.name)
          
          new_vm = VaccineManufacturer.find_by(vaccine: vaccine_regular, manufacturer: mfr_real, chain: chain)
          expect(new_vm).to be_present
        end
      end
    end # End context "when handling specific manufacturer name inputs"

  end # End describe "resolve"
end # bundle exec rspec spec/graphql/mutations/save_extracted_vaccine_applications_spec.rb

==================== ../netvacinas-frontend/src/components/UploadShots/types.ts ====================

// src/components/UploadShots/types.ts

// Fields extracted by Gemini and present in the `vaccine_applications` array
// This is the primary type for a single application object returned by Gemini.
export interface GeminiExtractedApplication {
  vaccine_name: string;
  application_date: string;
  manufacturer: string;
  batch_number: string;
  expiry_date: string;
  application_location: string;
  application_registry: string;
  applicator_name: string;
  is_existing_record: boolean;
  closest_known_active_vaccine: string;
  suggested_dose: string;
}

// Represents a vaccine from your system's active list
export interface SystemVaccine {
  id: string; // GraphQL Global ID
  name: string;
  doses: SystemDose[];
}

export interface SystemDose { // <<<< NEW
  id: string; // GraphQL Global ID
  label: string;
}

// The type used for managing applications in the frontend form's state
export type EditableVaccineApplication = GeminiExtractedApplication & {
  id: string | number; // Local unique ID for React list items
  isReviewed?: boolean;
  selectedVaccineId?: string | null; // GraphQL Global ID of the selected system vaccine
  selectedDoseId?: string | null; // GraphQL Global ID of the selected system dose

  saveError?: string | null; // Error message specific to this application after a save attempt
  saveSuccess?: boolean; // Flag indicating if this specific application was saved successfully

  // Store original values for fields that might have helper text showing original
  original_manufacturer?: string;
  original_batch_number?: string;
  original_expiry_date?: string;
  original_application_location?: string;
  original_application_registry?: string;
  original_applicator_name?: string;
  original_application_date?: string;
  // We don't need original_application_date for this specific helper text feature,
  // but you could add it if you had a similar requirement for it.
  // original_vaccine_name is already covered by `vaccine_name` which is displayed read-only.
};

// --- Types related to ProcessBase64File Mutation ---
export interface ProcessBase64FileInput {
  fileContentBase64: string;
  originalFilename: string;
  contentType: string;
  patientId: string;
}

// Structure of the geminiResponse from ProcessBase64File
export interface GeminiVaccinationCardData {
  vaccine_applications: GeminiExtractedApplication[];
}

// Payload type from the ProcessBase64File mutation
export interface ProcessGeminiFilePayload {
  success: boolean;
  geminiResponse: GeminiVaccinationCardData | null;
  errors: string[] | null;
}

// The overall structure of the data returned by the ProcessBase64File mutation
export interface ProcessBase64FileMutationData {
  processBase64File: {
    payload: ProcessGeminiFilePayload;
  };
}

export interface ProcessBase64FileMutationVars {
  input: ProcessBase64FileInput;
}

// --- Types related to SaveExtractedVaccineApplications Mutation ---
export interface ExtractedApplicationSaveInput {
  vaccineId: string | null | undefined;
  applicationDate: string;
  doseId?: string | null;
  manufacturerName?: string | null;
  batchNumber?: string | null;
  observations?: string | null;
}

export interface SaveExtractedVaccineApplicationsInput {
  patientId: string;
  applications: ExtractedApplicationSaveInput[];
}

export interface SavedShotPayload {
  id: string;
}

export interface ProcessedApplicationResultPayload {
  inputIndex: number;
  success: boolean;
  shot: SavedShotPayload | null;
  errors: string[] | null;
}

export interface SaveExtractedVaccineApplicationsPayload {
  overallSuccess: boolean;
  processedApplications: ProcessedApplicationResultPayload[];
}

export interface SaveExtractedVaccineApplicationsMutationData {
  saveExtractedVaccineApplications: {
    payload: SaveExtractedVaccineApplicationsPayload;
  };
}

export interface SaveExtractedVaccineApplicationsMutationVars {
  input: SaveExtractedVaccineApplicationsInput;
}

==================== ../netvacinas-frontend/src/components/UploadShots/useUploadShots.ts ====================

// /home/gnavarro/Development/netvacinas-frontend/src/components/UploadShots/useUploadShots.ts
import { useCallback, useEffect, useState } from "react";

import { ApolloError, useMutation } from "@apollo/client";

import { PROCESS_BASE64_FILE_MUTATION } from "../../data/queries";

import {
  GeminiVaccinationCardData,
  ProcessBase64FileInput,
  ProcessBase64FileMutationData,
  ProcessBase64FileMutationVars,
} from "./types";

interface UseUploadShotsProps {
  patientId: string;
  onUploadSuccess?: (response: GeminiVaccinationCardData | null) => void;
  onUploadError?: (errorMessages: string[] | null, rawError?: Error) => void;
}

interface UseUploadShotsReturn {
  isProcessing: boolean;
  error: string[] | null;
  processFile: (file: File) => Promise<void>;
  extractedData: GeminiVaccinationCardData | null;
}

export const useUploadShots = ({
  patientId,
  onUploadSuccess,
  onUploadError,
}: UseUploadShotsProps): UseUploadShotsReturn => {
  const [isProcessing, setIsProcessing] = useState<boolean>(false);
  const [error, setError] = useState<string[] | null>(null);
  const [extractedData, setExtractedData] = useState<GeminiVaccinationCardData | null>(null);

  const [callProcessBase64File, { loading: mutationLoading }] = useMutation<
    ProcessBase64FileMutationData,
    ProcessBase64FileMutationVars
  >(PROCESS_BASE64_FILE_MUTATION);

  const processFile = useCallback(
    async (file: File): Promise<void> => {
      if (!patientId) {
        // Should ideally not happen if prop is required
        const errMsg = ["ID do paciente não fornecido para o processamento."];
        console.error(errMsg[0]);
        setError(errMsg);
        onUploadError?.(errMsg, new Error(errMsg[0]));
        return;
      }
      if (!file) {
        const errMsg = ["Nenhum arquivo selecionado."];
        setError(errMsg);
        onUploadError?.(errMsg, new Error(errMsg[0]));
        return;
      }

      setIsProcessing(true);
      setError(null);
      setExtractedData(null); // Clear previous data

      // 1. Read file and convert to Base64
      const reader = new FileReader();
      reader.readAsDataURL(file); // Reads as Base64 Data URL

      reader.onload = async () => {
        const base64ContentWithPrefix = reader.result as string; // e.g., "data:image/png;base64,iVBORw0KGgo..."

        // The backend mutation strips the prefix, so sending it as is is fine.
        // Or, if you prefer to strip it client-side:
        // const base64Content = base64ContentWithPrefix.split(',')[1];

        const inputArgs: ProcessBase64FileInput = {
          fileContentBase64: base64ContentWithPrefix,
          originalFilename: file.name,
          contentType: file.type,
          patientId: patientId,
        };

        try {
          console.log(
            "Calling ProcessBase64File mutation for patient:",
            patientId,
            "with file:",
            inputArgs.originalFilename,
            inputArgs.contentType
          );
          const result = await callProcessBase64File({
            variables: { input: inputArgs },
          });

          // Check for GraphQL errors returned in the response body
          if (result.errors && result.errors.length > 0) {
            const errorMessages = result.errors.map(e => e.message);
            console.error("GraphQL errors from response:", errorMessages);
            setError(errorMessages);
            // Construct a new Error object for the onUploadError callback
            const rawError = new Error(errorMessages.join("; "));
            // You can optionally add more properties from result.errors[0] if needed
            // For example, if result.errors[0].extensions?.code exists:
            // (rawError as any).code = result.errors[0].extensions?.code;
            onUploadError?.(errorMessages, rawError);
            setIsProcessing(false); // Ensure processing is stopped
            return;
          }

          const payload = result.data?.processBase64File?.payload;

          if (payload?.success && payload.geminiResponse) {
            console.log("Processamento bem-sucedido:", payload.geminiResponse);
            setExtractedData(payload.geminiResponse);
            onUploadSuccess?.(payload.geminiResponse);
          } else {
            const backendErrors = payload?.errors || [
              "Erro desconhecido no processamento do backend.",
            ];
            console.error("Falha no processamento do backend:", backendErrors);
            setError(backendErrors);
            // For backend errors, we might not have a rawError object in the same way
            onUploadError?.(backendErrors, new Error(backendErrors.join("; ")));
          }
        } catch (err) {
          // This catch block handles network errors or other exceptions from Apollo Client
          console.error("Erro ao chamar a mutation (network or other client error):", err);
          let errorMessages: string[] = ["Ocorreu um erro inesperado."];
          let rawCaughtError: Error = new Error(errorMessages[0]);

          if (err instanceof ApolloError) {
            // ApolloError has a `graphQLErrors` array and a `networkError`
            if (err.graphQLErrors.length > 0) {
              errorMessages = err.graphQLErrors.map(e => e.message);
              rawCaughtError = new Error(errorMessages.join("; "));
              // (rawCaughtError as any).graphQLErrors = err.graphQLErrors; // Optionally attach original errors
            } else if (err.networkError) {
              errorMessages = [err.networkError.message || "Erro de rede."];
              rawCaughtError = err.networkError;
            } else {
              errorMessages = [err.message];
              rawCaughtError = err;
            }
          } else if (err instanceof Error) {
            errorMessages = [err.message];
            rawCaughtError = err;
          }

          setError(errorMessages);
          onUploadError?.(errorMessages, rawCaughtError);
        } finally {
          setIsProcessing(false);
        }
      };

      reader.onerror = fileReaderError => {
        console.error("Erro ao ler o arquivo:", fileReaderError);
        const errMsg = ["Erro ao ler o arquivo selecionado."];
        setError(errMsg);
        onUploadError?.(errMsg, new Error("FileReader error"));
        setIsProcessing(false);
      };
    },
    [callProcessBase64File, onUploadSuccess, onUploadError, patientId]
  );

  // Update isProcessing based on mutationLoading as well
  // This makes sure the UI reflects loading state from Apollo
  useEffect(() => {
    if (mutationLoading) {
      setIsProcessing(true);
    }
    // The `finally` block in `processFile` now handles setIsProcessing(false)
    // However, if the component unmounts while mutationLoading is true,
    // this effect might still be useful or could be removed if `finally` is robust.
    // For simplicity, let's rely on the finally block.
    // If `mutationLoading` becomes false, and `processFile` hasn't hit its `finally` yet,
    // `isProcessing` might flicker. The `finally` block is the most reliable place.
  }, [mutationLoading]);

  return { isProcessing, error, processFile, extractedData };
};
